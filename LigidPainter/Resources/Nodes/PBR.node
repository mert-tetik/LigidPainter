# For ligidtools.com
# Node extension v1.0

%attributes;

-title : Image Texture;
-color : hex30c959; #rgb122,124,66  #hsv86,45,23
-opacity : 60;



#Albedo
-input_0 : 
--list : none;
--list_index : none;
--type : vec3;
--title : Albedo;
--element : color;

#Roughness
-input_1 : 
--list : none;
--list_index : none;
--type : float;
--title : Roughness;
--element : range;

#Metallic
-input_2 : 
--list : none;
--list_index : none;
--type : float;
--title : Metallic;
--element : range;

#Normal
-input_3 : 
--list : none;
--list_index : none;
--type : vec3;
--title : Normal;
--element : image;

#Ambient occlusion
-input_4 : 
--list : none;
--list_index : none;
--type : float;
--title : Ambient occlusion;
--element : range;

#Emission
-input_5 : 
--list : none;
--list_index : none;
--type : vec3;
--title : Emission;
--element : range;

#Alpha
-input_6 : 
--list : none;
--list_index : none;
--type : float;
--title : Alpha;
--element : range;




-output_0 :
--list : none;
--list_index : none;
--type : vec3;
--title : Texture;


-uniforms : tex_coords|normal|posScene|posModel|viewPos|blurySkybox;

%code;

const float PI = 3.14159265359;


float distributionGGX(float NdotH, float roughness){
   float a     = roughness * roughness;
   float a2    = a * a;
   float denom = NdotH * NdotH * (a2 - 1.0) + 1.0;
   denom = PI * denom * denom;
   return a2 / max(denom,0.0000001);
}
float geometrySmith(float NdotV, float NdotL , float roughness){
   float r = roughness + 1.0;
   float k = (r * r) / 8.0;
   float ggx1 = NdotV / (NdotV * (1.0 - k) + k);
   float ggx2 = NdotL / (NdotL * (1.0 - k) + k);
   return ggx1 * ggx2;
}
vec3 fresnelSchlick(float HdotV, vec3 baseReflectivity){
   return baseReflectivity + (1.0 - baseReflectivity) * pow(1.0 - HdotV,5.0);
}
vec3 getRealisticResult(){
   
   vec3 albedo = texture2D(input_0,tex_coords).rgb;
   float roughness = texture2D(input_1,tex_coords).r;
   float metallic = texture2D(input_2,tex_coords).r;
   float ao = texture2D(input_4,tex_coords).r;

   vec3 lightPosX = vec3(10);
   vec3 lightColorX = vec3(300);


   vec3 N = normalize(normal);
   vec3 V = normalize(viewPos - posModel);

   vec3 baseReflectivity = mix(vec3(0.04), albedo, metallic);

   vec3 Lo = vec3(0.0);

   //for

   vec3 L = normalize(lightPosX - posModel);
   vec3 H = normalize(V + L);
   float distance = length(lightPosX - posModel);
   float attenuation = 1.0 / (distance*distance);
   vec3 radiance = lightColorX * attenuation;

   float NdotV = max(dot(N,V),0.0000001);
   float NdotL = max(dot(N,L),0.0000001);
   float HdotV = max(dot(H,V),0.0);
   float NdotH = max(dot(N,H),0.0);
   
   float D = distributionGGX(NdotH,roughness);
   float G = geometrySmith(NdotV,NdotL,roughness);
   vec3 F = fresnelSchlick(HdotV, baseReflectivity);

   vec3 specular = D * G * F;
   specular /= 4.0 * NdotV * NdotL;

   vec3 KD = vec3(1.0) - F;

   KD *=  1.0 - metallic;

   Lo += (KD * albedo / PI + specular) * radiance * NdotL;

   //For

    F = fresnelSchlick(NdotV, baseReflectivity);
    KD = (1.0 - F) * (1.0 - metallic);
   vec3 diffuse = texture(blurySkybox,N).rgb * albedo * KD;

   vec3 ambient = diffuse * ao;

   vec3 result = ambient + Lo;

   result = result / (result + vec3(1.0));

   result = pow(result,vec3(1.0/2.2));

   return result;
}

void main() {
    vec3 result = getRealisticResult();

    float alpha = texture2D(input_6,tex_coords).r;
    
    output_0 = vec4(result,alpha);
}