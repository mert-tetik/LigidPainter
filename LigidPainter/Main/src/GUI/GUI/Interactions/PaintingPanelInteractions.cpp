/*
---------------------------------------------------------------------------
LigidPainter - 3D Model texturing software / Texture generator   
---------------------------------------------------------------------------

Copyright (c) 2022-2023, Mert Tetik

All rights reserved.

Official GitHub Link : https://github.com/mert-tetik/LigidPainter
Official Web Page : https://ligidtools.com/ligidpainter

---------------------------------------------------------------------------
*/


#include<glad/glad.h>

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include "GUI/GUI.hpp"
#include "3D/ThreeD.hpp"
#include "MouseSystem/Mouse.hpp"
#include "SettingsSystem/Settings.hpp"
#include "LibrarySystem/Library.hpp"

#include <string>
#include <fstream>
#include <sstream>
#include <iostream>
#include <map>
#include <vector>
#include <filesystem>

void UI::paintingPanelInteraction(
                                Painter &painter 
                            )
{

    //Get the brush data from GUI to the painter class
    painter.brushProperties.radius = brushSection.elements[1].rangeBar.value;
    painter.brushProperties.opacity = brushSection.elements[2].rangeBar.value;
    painter.brushProperties.hardness = brushSection.elements[3].rangeBar.value;
    painter.brushProperties.spacing = brushSection.elements[4].rangeBar.value;
    painter.brushProperties.sizeJitter = brushSection.elements[5].rangeBar.value;
    painter.brushProperties.fade = brushSection.elements[6].rangeBar.value;
    painter.brushProperties.sinWavePattern = brushSection.elements[7].checkBox.clickState1;
    painter.brushProperties.scatter = brushSection.elements[8].rangeBar.value;
    painter.brushProperties.brushTexture = brushSection.elements[9].button.texture;
    painter.brushProperties.individualTexture = brushSection.elements[11].checkBox.clickState1;
    painter.brushProperties.rotation = brushSection.elements[12].rangeBar.value;
    painter.brushProperties.rotationJitter = brushSection.elements[13].rangeBar.value;
    painter.brushProperties.alphaJitter = brushSection.elements[14].rangeBar.value;

    
    if(colorSection.elements[0].button.hover && *Mouse::LDoubleClick()){//Pressed to first color button element
        painter.loadColor1();
    }
    if(colorSection.elements[1].button.hover && *Mouse::LDoubleClick()){//Pressed to second color button element
        painter.loadColor2();
    }
    if(colorSection.elements[2].button.hover && *Mouse::LDoubleClick()){//Pressed to third color button element
        painter.loadColor3();
    }

    //Prevent multiple selection and update the painter.selectedColorIndex for colors
    for (size_t i = 0; i < colorSection.elements.size(); i++)
    {
        if(i == 3) 
            break; //Don't bring the dropper button
        
        if(colorSection.elements[i].button.clickState1){ //If a color button is clicked
         
            if(painter.selectedColorIndex != i){ //If the clicked button is not selected 
                colorSection.elements[painter.selectedColorIndex].button.clickState1 = false; //Unselect the selected one
                painter.selectedColorIndex = i; //Select the clicked color button
                break; 
            }
        
        }

    }

    //Keep the selected color button pressed
    for (size_t i = 0; i < colorSection.elements.size(); i++){
        if(i == painter.selectedColorIndex){
            colorSection.elements[i].button.clickState1 = true;           
        }
    }
    
    //Update the color values of the color buttons
    colorSection.elements[0].button.color = glm::vec4(painter.color1.getRGB_normalized(), 1.f);
    colorSection.elements[1].button.color = glm::vec4(painter.color2.getRGB_normalized(), 1.f);
    colorSection.elements[2].button.color = glm::vec4(painter.color3.getRGB_normalized(), 1.f);
    

    //If clicked to the dropper button activate the dropper
    if(colorSection.elements[3].button.hover && *Mouse::LClick()){
        dropper.active = true;
    }

    if(brushSection.elements[10].button.hover && *Mouse::LClick()){ //If pressed to remove the brush texture button from brush/more
        char whitePixel[] = { 127, 127, 127, 127 };
        brushSection.elements[9].button.textureSelection2D = true;
        brushSection.elements[9].button.texture = Texture(whitePixel, 1, 1, GL_NEAREST);
        brushSection.elements[9].button.texture.proceduralProps.proceduralID = 24; //Solid white
        brushSection.elements[9].button.texture.proceduralProps.proceduralnverted = 0;
        brushSection.elements[9].button.texture.proceduralProps.proceduralScale = 1.f;
        brushSection.elements[9].button.texture.title = "AutoGeneratedMask";        
    }
    
    if(brushSection.elements[15].button.hover && *Mouse::LClick()){ //If pressed to create new brush button
        Brush newBrush
                        (    
                            0.1f,
                            painter.brushProperties.spacing,
                            painter.brushProperties.hardness,
                            painter.brushProperties.sizeJitter,
                            painter.brushProperties.scatter,
                            painter.brushProperties.fade,
                            painter.brushProperties.rotation,
                            painter.brushProperties.rotationJitter,
                            painter.brushProperties.alphaJitter,
                            painter.brushProperties.individualTexture,
                            painter.brushProperties.sinWavePattern,
                            "newBrush",
                            painter.brushProperties.brushTexture
                        );

        Library::addBrush(newBrush);
    }
    
    if(brushSection.elements[16].button.hover && *Mouse::LClick()){ //If pressed to export brush file button
        Brush exportBrush
                        (    
                            0.1f,
                            painter.brushProperties.spacing,
                            painter.brushProperties.hardness,
                            painter.brushProperties.sizeJitter,
                            painter.brushProperties.scatter,
                            painter.brushProperties.fade,
                            painter.brushProperties.rotation,
                            painter.brushProperties.rotationJitter,
                            painter.brushProperties.alphaJitter,
                            painter.brushProperties.individualTexture,
                            painter.brushProperties.sinWavePattern,
                            "exportBrush",
                            painter.brushProperties.brushTexture
                        );

        FileHandler::writeLGDBRUSHFile("", exportBrush);

        // Delete the OpenGL texture buffers created with the export brush
        glDeleteTextures(1, &exportBrush.texture.ID);
        glDeleteTextures(1, &exportBrush.displayingTexture.ID);
        
    }

    //Update the meshes section of the painting panel if a new model is added
    if(getModel()->newModelAdded){
        meshSection.elements[0].button.selectedMeshI = 0;
    }

    painter.selectedMeshIndex = meshSection.elements[0].button.selectedMeshI;

    //Check all the mesh buttons if they are pressed
    for (size_t i = 0; i < paintingChannelsSection.elements.size(); i++) 
    {
        if(paintingChannelsSection.elements[i].button.hover && *Mouse::LClick()){//If any button element is pressed
            if(painter.selectedPaintingChannelIndex != i){
                paintingChannelsSection.elements[painter.selectedPaintingChannelIndex].button.clickState1 = false;
                painter.selectedPaintingChannelIndex = i;
                painter.selectedTexture = paintingChannelsSection.elements[painter.selectedPaintingChannelIndex].button.texture;
                break;
            }
        } 
    }

    //Set the selected mesh button as selected 
    for (size_t i = 0; i < paintingChannelsSection.elements.size(); i++)
    {
        if(i == painter.selectedPaintingChannelIndex)
            paintingChannelsSection.elements[i].button.clickState1 = true;
    }

    painter.oSide.active = true;
    
    painter.oXSide.active = mirrorSection.elements[0].checkBox.clickState1; 
    painter.mirrorXOffset = mirrorSection.elements[1].rangeBar.value;
    painter.oYSide.active = mirrorSection.elements[2].checkBox.clickState1; 
    painter.mirrorYOffset = mirrorSection.elements[3].rangeBar.value;
    painter.oZSide.active = mirrorSection.elements[4].checkBox.clickState1; 
    painter.mirrorZOffset = mirrorSection.elements[5].rangeBar.value;


    painter.oXYSide.active = painter.oXSide.active && painter.oYSide.active;     
    painter.oXZSide.active = painter.oXSide.active && painter.oZSide.active; 
    painter.oYZSide.active = painter.oYSide.active && painter.oZSide.active; 
    painter.oXYZSide.active = painter.oXSide.active && painter.oYSide.active && painter.oZSide.active; 

    // Updating the depth texture if interacted with the gui elements related to mirroring
    if( 
        mirrorSection.elements[0].isInteracted() || 
        mirrorSection.elements[1].isInteracted() || 
        mirrorSection.elements[2].isInteracted() || 
        mirrorSection.elements[3].isInteracted() || 
        mirrorSection.elements[4].isInteracted() || 
        mirrorSection.elements[5].isInteracted()
    ) {
        painter.updateDepthTexture();
    }


    brushSection.elements[0].button.texture = painter.displayingBrush.displayingTexture; 

    if(!painter.displayingBrush.displayingTexture.ID){
        // Init brush settings displaying brush
        painter.displayingBrush = Brush(
                                            painter.brushProperties.radius * 2.f,
                                            painter.brushProperties.spacing,
                                            painter.brushProperties.hardness,
                                            painter.brushProperties.sizeJitter,
                                            painter.brushProperties.scatter,
                                            painter.brushProperties.fade,
                                            painter.brushProperties.rotation,
                                            painter.brushProperties.rotationJitter,
                                            painter.brushProperties.alphaJitter,
                                            painter.brushProperties.individualTexture,
                                            painter.brushProperties.sinWavePattern,
                                            "BrushSettingsDisplayingBrush",
                                            painter.brushProperties.brushTexture
                                        );
    }
    
    for (size_t i = 0; i < brushSection.elements.size(); i++)
    {
        if(brushSection.elements[i].isInteracted() || (ContextMenus::brush.contextPanel.sections[0].elements[0].button.hover && *Mouse::LClick())){
            // Update brush settings displaying brush
            painter.displayingBrush.update(
                                                painter.brushProperties.radius * 2.f,
                                                painter.brushProperties.spacing,
                                                painter.brushProperties.hardness,
                                                painter.brushProperties.sizeJitter,
                                                painter.brushProperties.scatter,
                                                painter.brushProperties.fade,
                                                painter.brushProperties.rotation,
                                                painter.brushProperties.rotationJitter,
                                                painter.brushProperties.alphaJitter,
                                                painter.brushProperties.individualTexture,
                                                painter.brushProperties.sinWavePattern,
                                                painter.brushProperties.brushTexture
                                            );
        }
    }
    
    for (size_t i = 0; i < paintingPanelModePanel.sections[0].elements.size(); i++)
    {
        if(paintingPanelModePanel.sections[0].elements[i].button.clickState1 && selectedPaintingPanelMode != i){
            selectedPaintingPanelMode = i;
            for (size_t i = 0; i < paintingPanelModePanel.sections[0].elements.size(); i++){
                paintingPanelModePanel.sections[0].elements[i].button.clickState1 = false;
            }
        }
        if(selectedPaintingPanelMode == i){
            paintingPanelModePanel.sections[0].elements[i].button.clickState1 = true;
        }
        else{
            paintingPanelModePanel.sections[0].elements[i].button.clickState1 = false;
        }
    }
    for (size_t i = 0; i < paintingPanelModePanel.sections[0].elements.size(); i++){
        if(i == selectedPaintingPanelMode){
            paintingPanelModePanel.sections[0].elements[i].button.clickState1 = true;
        }
    }
}