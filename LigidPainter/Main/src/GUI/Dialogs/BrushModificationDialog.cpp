/*
---------------------------------------------------------------------------
LigidPainter - 3D Model texturing software / Texture generator   
---------------------------------------------------------------------------

(c) 2024 Mert Tetik. All rights reserved.

Official GitHub Link : https://github.com/mert-tetik/LigidPainter
Official Web Page : https://ligidtools.com/ligidpainter

---------------------------------------------------------------------------

    Texture selection dialog is responsible of modifying the procedural variables inside of a Texture class & generating displaying textures

*/

#include<glad/glad.h>
#include "LigidGL/LigidGL.hpp"

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/string_cast.hpp>

#include "GUI/GUI.hpp"
#include "LibrarySystem/Library.hpp"
#include "MouseSystem/Mouse.hpp"
#include "ColorPaletteSystem/ColorPalette.hpp"

#include <string>
#include <iostream>
#include <vector>

static const unsigned int brushTextureResolution = 256; 

BrushModificationDialog::BrushModificationDialog(){
    this->bgPanel = Panel(
                            {
                                Section(
                                    Element(),
                                    {   
                                        Element(RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(2,1),"Radius"  , Texture(), 2.f, 0.005f, 0.05f, 0.01f)), //0
                                        Element(RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(2,1),"Opacity"  , Texture(), 1.f, 0.f, 1.f, 1.f)), //1
                                        Element(RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(2,1),"Hardness"  , Texture(), 1.f, -10.f, 10.f, 0.f)), //2
                                        Element(RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(2,1),"Spacing"  , Texture(), 1.f, 0.f, 100.f, 0.f)), //3

                                        Element(RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(2,1),"Size Jitter"  , Texture(), 4.f, 0.f, 1.f, 0.f)), //4
                                        Element(RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(2,1),"Fade"  , Texture(), 1.f, 0.f, 1.f, 0.f)), //5
                                        Element(CheckBox(ELEMENT_STYLE_BASIC,glm::vec2(2,2),"Sin Wave Pattern"  , 1.f)), //6
                                        Element(RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(2,1),"Scatter"  , Texture(), 1.f, 0.f, 1.f, 0.f)), //7
                                        Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(2,4),"Texture"  , Texture(), 1.f, false)), //8
                                        Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(2,1),"Remove"  , Texture(), 0.f,false)), //9
                                        Element(CheckBox(ELEMENT_STYLE_BASIC,glm::vec2(2,2),"Individual Texture"  , 1.f)), //10
                                        Element(RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(2,1),"Rotation"  , Texture(), 1.f, 0.f, 360.f, 0.f)), //11
                                        Element(RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(2,1),"Rotation Jitter"  , Texture(), 1.f, 0.f, 1.f, 0.f)), //12
                                        Element(RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(2,1),"Alpha Jitter"  , Texture(), 1.f, 0.f, 1.f, 0.f)), //13
                                        Element(Button(ELEMENT_STYLE_BASIC,glm::vec2(2,1),"Set Default Properties"  , Texture(), 0.5f,false)), //14
                                        Element(Button(ELEMENT_STYLE_BASIC,glm::vec2(2,1),"Cancel Changes"  , Texture(), 0.5f,false)),//15
                                    }
                                )
                            }, 
                        glm::vec2(10.f, 20.f), glm::vec3(50.f, 50.f, 0.7), ColorPalette::secondColor, ColorPalette::thirdColor, true, true, false, true, true, 1.f, 1, {}, 20.f, true);
    
    this->bgPanel.solidStyle = true;
    
    this->bgPanel.sections[0].elements[8].button.textureSelection2D = true;
    this->bgPanel.sections[0].elements[8].button.texture.proceduralProps.proceduralID = 24; //Solid white
    this->bgPanel.sections[0].elements[8].button.texture.proceduralProps.proceduralnverted = 0;
    this->bgPanel.sections[0].elements[8].button.texture.proceduralProps.proceduralScale = 1.f;
    this->bgPanel.sections[0].elements[8].button.texture.title = "AutoGeneratedMask";

    this->brushDisplayBtn = Button(ELEMENT_STYLE_SOLID,glm::vec2(2,5), ""  , Texture(), 7.f, false);
}

//Forward declarations for the utility functions
static void drawBG(unsigned int bgTexture);

BrushProperties initialProperties;

Brush displayBrush;

void BrushModificationDialog::show(Timer &timer, glm::mat4 guiProjection, BrushProperties* brushProperties){
        
    ShaderSystem::buttonShader().use();
    ShaderSystem::buttonShader().setMat4("projection", guiProjection);
    Settings::defaultFramebuffer()->setViewport(); 

    char whiteTxtr[brushTextureResolution * brushTextureResolution * 4];
    for (size_t i = 0; i < brushTextureResolution * brushTextureResolution * 4; i++)
    {
        whiteTxtr[i] = 127;
    }
        
    if(!this->bgPanel.sections[0].elements[8].button.texture.ID){
        this->bgPanel.sections[0].elements[8].button.texture = Texture(whiteTxtr, brushTextureResolution, brushTextureResolution);
    }
    if(!brushProperties->brushTexture){
        brushProperties->brushTexture = Texture(whiteTxtr, brushTextureResolution, brushTextureResolution).ID;
    }
    
    this->dialogControl.activate();

    this->outToIn(brushProperties);

    initialProperties = *brushProperties;

    while (!getContext()->window.shouldClose())
    {
        getContext()->window.pollEvents();
        
        // Prevent rendering the application if the window is minimized
        while (getContext()->window.isMinimized()){
            getContext()->window.pollEvents();
        }
        
        glClearColor(0,0,0,0);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        drawBG(Settings::defaultFramebuffer()->bgTxtr.ID);

        dialogControl.updateStart();

        //Render the panel
        this->bgPanel.render(timer, true);
        this->brushDisplayBtn.texture = displayBrush.displayingTexture;
        this->brushDisplayBtn.scale.x = this->bgPanel.scale.x;
        this->brushDisplayBtn.pos = glm::vec3(this->bgPanel.pos.x, this->bgPanel.pos.y - this->bgPanel.scale.y - this->brushDisplayBtn.scale.y, this->bgPanel.pos.z);
        this->brushDisplayBtn.render(timer, false);

        bool anyInteractions = false;
        for (size_t i = 0; i < this->bgPanel.sections[0].elements.size(); i++)
        {
            if(this->bgPanel.sections[0].elements[i].isInteracted()){

                // Set Default Properties button clicked 
                if(i == 9){
                    char whiteTxtr[brushTextureResolution * brushTextureResolution * 4];
                    for (size_t i = 0; i < brushTextureResolution * brushTextureResolution * 4; i++)
                    {
                        whiteTxtr[i] = 127;
                    }
                    
                    this->bgPanel.sections[0].elements[9].button.texture.update(whiteTxtr, brushTextureResolution, brushTextureResolution);
                    this->bgPanel.sections[0].elements[9].button.texture.proceduralProps = ProceduralProperties();
                    this->bgPanel.sections[0].elements[9].button.texture.proceduralProps.proceduralID = 24; //Solid white
                }

                if(i == 14){
                    this->applyDefaultBrushProperties(brushProperties);
                    this->outToIn(brushProperties);
                }
                if(i == 15){
                    this->cancelChanges(brushProperties);
                    this->outToIn(brushProperties);
                }
                
                anyInteractions = true;
            }
        }
        
        if(anyInteractions){
            this->inToOut(brushProperties);
            this->updateDisplayingTexture(brushProperties);
            ShaderSystem::buttonShader().use();
            ShaderSystem::buttonShader().setMat4("projection", guiProjection);  
        }

        dialogControl.updateEnd(timer,0.15f);

        //End the dialog
        if((getContext()->window.isKeyPressed(LIGIDGL_KEY_ESCAPE)) || (!this->bgPanel.hover && *Mouse::LClick())){
            dialogControl.unActivate();
        }

        if(!this->dialogControl.isActive())
            break;
            
        dialogControl.updateEnd(timer,0.15f);

        getContext()->window.swapBuffers();

        //Set mouse states to default
        *Mouse::LClick() = false;
        *Mouse::RClick() = false;
        *Mouse::MClick() = false;
        *Mouse::LDoubleClick() = false;
        *Mouse::mouseOffset() = glm::vec2(0);
        *Mouse::mods() = 0;
        *Mouse::mouseScroll() = 0;
        *Mouse::action() = 0;
        Mouse::updateCursor();  

        //Set keyboard states to default
        textRenderer.keyInput = false;
        textRenderer.mods = 0;

        Settings::defaultFramebuffer()->render();    
        Settings::defaultFramebuffer()->setViewport();   


    }

    ShaderSystem::buttonShader().use();
    ShaderSystem::buttonShader().setMat4("projection", guiProjection);
    Settings::defaultFramebuffer()->FBO.bind();
    Settings::defaultFramebuffer()->setViewport(); 
}





// ---------- UTILITY FUNCTIONS -----------


void BrushModificationDialog::updateDisplayingTexture(BrushProperties* brushProperties){
    if(!displayBrush.displayingTexture.ID)
        displayBrush = Brush(
                                    brushProperties->radius, 
                                    brushProperties->spacing,
                                    brushProperties->hardness,
                                    brushProperties->sizeJitter, 
                                    brushProperties->scatter,
                                    brushProperties->fade,
                                    brushProperties->rotation,
                                    brushProperties->rotationJitter,
                                    brushProperties->alphaJitter,
                                    brushProperties->individualTexture,
                                    brushProperties->sinWavePattern,
                                    "",
                                    brushProperties->brushTexture
                                );

    displayBrush.update(
                                brushProperties->radius, 
                                brushProperties->spacing,
                                brushProperties->hardness,
                                brushProperties->sizeJitter, 
                                brushProperties->scatter,
                                brushProperties->fade,
                                brushProperties->rotation,
                                brushProperties->rotationJitter,
                                brushProperties->alphaJitter,
                                brushProperties->individualTexture,
                                brushProperties->sinWavePattern,
                                brushProperties->brushTexture
                            );
    
    displayBrush.updateDisplayTexture(brushProperties->radius);

    Settings::defaultFramebuffer()->FBO.bind();
    Settings::defaultFramebuffer()->setViewport();
    getBox()->bindBuffers();
}

void BrushModificationDialog::inToOut(BrushProperties* brushProperties){

    if(Texture(brushProperties->brushTexture).getResolution() != this->bgPanel.sections[0].elements[8].button.texture.getResolution())
        Texture(brushProperties->brushTexture).update(nullptr, this->bgPanel.sections[0].elements[8].button.texture.getResolution().x, this->bgPanel.sections[0].elements[8].button.texture.getResolution().y);

    brushProperties->radius = this->bgPanel.sections[0].elements[0].rangeBar.value;
    brushProperties->opacity = this->bgPanel.sections[0].elements[1].rangeBar.value;
    brushProperties->hardness = this->bgPanel.sections[0].elements[2].rangeBar.value;
    brushProperties->spacing = this->bgPanel.sections[0].elements[3].rangeBar.value;

    brushProperties->sizeJitter = this->bgPanel.sections[0].elements[4].rangeBar.value;
    brushProperties->fade = this->bgPanel.sections[0].elements[5].rangeBar.value;
    brushProperties->sinWavePattern = this->bgPanel.sections[0].elements[6].checkBox.clickState1;
    brushProperties->scatter = this->bgPanel.sections[0].elements[7].rangeBar.value;
    Texture txtrOBJ = brushProperties->brushTexture;
    this->bgPanel.sections[0].elements[8].button.texture.duplicateTextureSub(txtrOBJ);

    brushProperties->individualTexture = this->bgPanel.sections[0].elements[10].checkBox.clickState1;
    brushProperties->rotation = this->bgPanel.sections[0].elements[11].rangeBar.value;
    brushProperties->rotationJitter = this->bgPanel.sections[0].elements[12].rangeBar.value;
    brushProperties->alphaJitter = this->bgPanel.sections[0].elements[13].rangeBar.value;
}

void BrushModificationDialog::outToIn(BrushProperties* brushProperties){
    if(Texture(brushProperties->brushTexture).getResolution() != this->bgPanel.sections[0].elements[8].button.texture.getResolution())
        Texture(brushProperties->brushTexture).update(nullptr, this->bgPanel.sections[0].elements[8].button.texture.getResolution().x, this->bgPanel.sections[0].elements[8].button.texture.getResolution().y);
    
    this->bgPanel.sections[0].elements[0].rangeBar.value = brushProperties->radius;
    this->bgPanel.sections[0].elements[1].rangeBar.value = brushProperties->opacity;
    this->bgPanel.sections[0].elements[2].rangeBar.value = brushProperties->hardness;
    this->bgPanel.sections[0].elements[3].rangeBar.value = brushProperties->spacing;

    this->bgPanel.sections[0].elements[4].rangeBar.value = brushProperties->sizeJitter;
    this->bgPanel.sections[0].elements[5].rangeBar.value = brushProperties->fade;
    this->bgPanel.sections[0].elements[6].checkBox.clickState1 = brushProperties->sinWavePattern;
    this->bgPanel.sections[0].elements[7].rangeBar.value = brushProperties->scatter;
    Texture(brushProperties->brushTexture).duplicateTextureSub(this->bgPanel.sections[0].elements[8].button.texture);
    
    this->bgPanel.sections[0].elements[10].checkBox.clickState1 = brushProperties->individualTexture;
    this->bgPanel.sections[0].elements[11].rangeBar.value = brushProperties->rotation;
    this->bgPanel.sections[0].elements[12].rangeBar.value = brushProperties->rotationJitter;
    this->bgPanel.sections[0].elements[13].rangeBar.value = brushProperties->alphaJitter;
}

void BrushModificationDialog::applyDefaultBrushProperties(BrushProperties* brushProperties){
    *brushProperties = BrushProperties();
    brushProperties->radius = 0.01f;
    brushProperties->opacity = 1.0f;
}

void BrushModificationDialog::cancelChanges(BrushProperties* brushProperties){
    *brushProperties = initialProperties;
}

static void drawBG(
                    unsigned int bgTexture
                )
{
    ShaderSystem::defaultFramebufferShader().use();
    ShaderSystem::defaultFramebufferShader().setMat4("projection", glm::ortho(0.f, 1.f, 1.f, 0.f));
    ShaderSystem::defaultFramebufferShader().setVec3("pos", glm::vec3(0.5f, 0.5f, 0.6f));
    ShaderSystem::defaultFramebufferShader().setVec2("scale", glm::vec2(0.5f));
    
    ShaderSystem::defaultFramebufferShader().setVec2("resolution", Settings::defaultFramebuffer()->resolution);
    ShaderSystem::defaultFramebufferShader().setInt("txtr", 0);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, bgTexture);

    LigidGL::makeDrawCall(GL_TRIANGLES, 0, 6, "Mesh selection dialog : DrawBG");
    
    ShaderSystem::buttonShader().use();
}