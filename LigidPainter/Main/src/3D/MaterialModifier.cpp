/*
---------------------------------------------------------------------------
LigidPainter - 3D Model texturing software / Texture generator   
---------------------------------------------------------------------------

Copyright (c) 2022-2023, Mert Tetik

All rights reserved.

Official GitHub Link : https://github.com/mert-tetik/LigidPainter
Official Web Page : https://ligidtools.com/ligidpainter

---------------------------------------------------------------------------

    Texture Modifier

    Dust Modifier

    Solid Modifier

    Fabric Modifier

    Ceramic Modifier

    Leather Modifier

    Rust Modifier

    Wooden Modifier

    Brick Modifier

    Image Repeate Modifier

    Shapes Modifier

    Seams Modifier

    Cracks Modifier
    
    Dirt Modifier
    
    Line Modifier

    Skin Modifier
*/

#include<glad/glad.h>
#include "LigidGL/LigidGL.hpp"

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include <glm/gtc/type_ptr.hpp>

#include <string>
#include <iostream>
#include <vector>

#include "GUI/Elements/Elements.hpp"
#include "UTIL/Util.hpp"
#include "3D/ThreeD.hpp"
#include "ShaderSystem/Shader.hpp"

//0 = albedo
//1 = roughness
//2 = metallic 
//3 = normal map
//4 = height map
//5 = ambient Occlusion

MaterialModifier::MaterialModifier(){}

void textureModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view);
void dustModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view);
void solidModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view);
void asphaltModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view);
void fabricModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view);
void woodenModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view);
void mossModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view);
void rustModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view);
void skinModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view);

MaterialModifier::MaterialModifier(ColorPalette colorPalette, int modifierIndex){
    
    /* Init the mask texture */
    this->maskTexture.proceduralID = 24; //Solid white
    this->maskTexture.proceduralnverted = 0;
    this->maskTexture.proceduralScale = 1.f;
    this->maskTexture.title = "AutoGeneratedMask";

    // Create a 1x1 pixel white texture for the procedural texture displaying
    unsigned char whitePixel[] = { 255, 255, 255, 255 }; // 1 pixel, RGBA format (white)
    glGenTextures(1, &this->maskTexture.ID);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, this->maskTexture.ID);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, whitePixel);

    // Set texture parameters 
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_MIRRORED_REPEAT);

    glBindTexture(GL_TEXTURE_2D, 0);

    if(modifierIndex == TEXTURE_MATERIAL_MODIFIER){
        this->sections = createTextureModifier(colorPalette);
        this->title = "Texture Modifier";    
        this->shader = Shader("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/TextureModifier.frag",nullptr,nullptr,nullptr);
        this->updateMaterialChannels = textureModifierUpdateMat;
    }
    else if(modifierIndex == DUST_MATERIAL_MODIFIER){
        this->sections = createDustModifier(colorPalette);
        this->title = "Dust Modifier";    
        this->shader = Shader("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/DustModifier.frag",nullptr,nullptr,nullptr);
        this->updateMaterialChannels = dustModifierUpdateMat;
    }
    else if(modifierIndex == ASPHALT_MATERIAL_MODIFIER){
        this->sections = createAsphaltModifier(colorPalette);
        this->title = "Asphalt Modifier";    
        this->shader = Shader("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/AsphaltModifier.frag",nullptr,nullptr,nullptr);
        this->updateMaterialChannels = asphaltModifierUpdateMat;
    }
    else if(modifierIndex == FABRIC_MATERIAL_MODIFIER){
        this->sections = createFabricModifier(colorPalette);
        this->title = "Fabric Modifier";    
        this->shader = Shader("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/FabricModifier.frag",nullptr,nullptr,nullptr);
        this->updateMaterialChannels = fabricModifierUpdateMat;
    }
    else if(modifierIndex == MOSS_MATERIAL_MODIFIER){
        this->sections = createMossModifier(colorPalette);
        this->title = "Moss Modifier";    
        this->shader = Shader("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/MossModifier.frag",nullptr,nullptr,nullptr);
        this->updateMaterialChannels = mossModifierUpdateMat;
    }
    else if(modifierIndex == RUST_MATERIAL_MODIFIER){
        this->sections = createRustModifier(colorPalette);
        this->title = "Rust Modifier";    
        this->shader = Shader("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/RustModifier.frag",nullptr,nullptr,nullptr);
        this->updateMaterialChannels = rustModifierUpdateMat;
    }
    else if(modifierIndex == SKIN_MATERIAL_MODIFIER){
        this->sections = createSkinModifier(colorPalette);
        this->title = "Skin Modifier";    
        this->shader = Shader("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/SkinModifier.frag",nullptr,nullptr,nullptr);
        this->updateMaterialChannels = skinModifierUpdateMat;
    }
    else if(modifierIndex == SOLID_MATERIAL_MODIFIER){
        this->sections = createSolidModifier(colorPalette);
        this->title = "Solid Modifier";    
        this->shader = Shader("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/SolidModifier.frag",nullptr,nullptr,nullptr);
        this->updateMaterialChannels = solidModifierUpdateMat;
    }
    else if(modifierIndex == WOODEN_MATERIAL_MODIFIER){
        this->sections = createWoodenModifier(colorPalette);
        this->title = "Wooden Modifier";    
        this->shader = Shader("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/WoodenModifier.frag",nullptr,nullptr,nullptr);
        this->updateMaterialChannels = woodenModifierUpdateMat;
    }

    this->modifierIndex = modifierIndex;
}

#define MATERIAL_MODIFIERS_ELEMENT_OFFSET 2.5f

std::vector<Section> MaterialModifier::createTextureModifier(ColorPalette colorPalette){
        
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Channels",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Albedo",              Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false)),
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Roughness",           Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false)),
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Metallic",            Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false)),
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Normal map",          Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false)),
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Height map",          Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false)),
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Ambient Occlusion",   Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false))
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f),
            }
        )
    };

    sections[0].elements[0].button.textureSelection = true;
    sections[0].elements[1].button.textureSelection = true;
    sections[0].elements[2].button.textureSelection = true;
    sections[0].elements[3].button.textureSelection = true;
    sections[0].elements[4].button.textureSelection = true;
    sections[0].elements[5].button.textureSelection = true;

    return sections;
}

std::vector<Section> MaterialModifier::createSolidModifier(ColorPalette colorPalette){
        
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Channels",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Albedo",              Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Roughness",           Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Metallic",            Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Normal Map",          Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Height map",          Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Ambient Occlusion",   Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f ) // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f),
                CheckBox(ELEMENT_STYLE_BASIC, glm::vec2(1.f, 2.f), colorPalette, "Blur the Height Map", MATERIAL_MODIFIERS_ELEMENT_OFFSET)
            }
        )
    };

    sections[0].elements[0].button.colorSelection = true;
    sections[0].elements[2].button.colorSelection = true;
    sections[0].elements[4].button.colorSelection = true;
    sections[0].elements[6].button.colorSelection = true;
    sections[0].elements[6].button.color = glm::vec4(0.5f,0.5f,1.f,1.f);
    sections[0].elements[8].button.colorSelection = true;
    sections[0].elements[10].button.colorSelection = true;

    return sections;
}

std::vector<Section> MaterialModifier::createFabricModifier(ColorPalette colorPalette){
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Stripes",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette, "Color",   Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false),
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Scale",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,32.f), // 1
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Frequency",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,20.f), // /2
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Gap Frequency",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,60.f), // /2
                RangeBar(ELEMENT_STYLE_STYLIZED,glm::vec2(1,1.5f),colorPalette,"Style",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0,2,0),  
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Element Properties",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Wetness",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Metallic",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,0.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Height",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f),
            }
        )
    };

    sections[0].elements[0].button.colorSelection = true;

    sections[0].elements[0].button.color = glm::vec4(glm::vec3(0.79f, 0.79f, 0.73f), 1.f);

    return sections;
} 

std::vector<Section> MaterialModifier::createMossModifier(ColorPalette colorPalette)
{
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Color", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Moss Color Back", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Moss Color Front", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Dirt Color", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Droplets", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Droplets Count", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f), // /1
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Droplets Opacity Jitter", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Droplets Size", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 15.f), // /10
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Front Layer", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Front Layer Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Front Layer Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 200.f, 50.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Lighting", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Light Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 200.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Darkening Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 200.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Noise", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Noise Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 200.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Moss Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f), // /1
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Element Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Wetness", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 40.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Metallic", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 0.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Height", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f),
                CheckBox(ELEMENT_STYLE_BASIC, glm::vec2(1.f, 2.f), colorPalette, "Blur the Height Map", MATERIAL_MODIFIERS_ELEMENT_OFFSET)
            }
        )
    };

    sections[0].elements[0].button.colorSelection = true;
    sections[0].elements[1].button.colorSelection = true;
    sections[0].elements[2].button.colorSelection = true;

    sections[0].elements[0].button.color = glm::vec4(glm::vec3(0.19f, 0.19f, 0.13f), 1.f);
    sections[0].elements[1].button.color = glm::vec4(glm::vec3(0.21f, 0.27f, 0.01f), 1.f);
    sections[0].elements[2].button.color = glm::vec4(glm::vec3(0.27f, 0.22f, 0.15f), 1.f);
    

    return sections;
}

std::vector<Section> MaterialModifier::createRustModifier(ColorPalette colorPalette)
{
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Colors", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Color 1", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Color 2", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Color 3", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Color 4", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 30.f), // /1
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Perlin Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_STYLIZED, glm::vec2(1, 1.5f), colorPalette, "First Octave", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 8, 3 ), 
                RangeBar(ELEMENT_STYLE_STYLIZED, glm::vec2(1, 1.5f), colorPalette, "Octaves", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 8, 8 ), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Persistence", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 60.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "FBM Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_STYLIZED, glm::vec2(1, 1.5f), colorPalette, "FBM Octaves", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 16, 16 ), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "FBM Roughness", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 50.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Rust Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Rust Radius", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 20.f), // /10
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Battering Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 200, 100), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Noise Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Noise Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 200.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Element Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Wetness", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Metallic", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 0.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Height", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 0.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f),
                CheckBox(ELEMENT_STYLE_BASIC, glm::vec2(1.f, 2.f), colorPalette, "Blur the Height Map", MATERIAL_MODIFIERS_ELEMENT_OFFSET)
            }
        )
    };
    
    sections[0].elements[0].button.colorSelection = true;
    sections[0].elements[1].button.colorSelection = true;
    sections[0].elements[2].button.colorSelection = true;
    sections[0].elements[3].button.colorSelection = true;

    sections[0].elements[0].button.color = glm::vec4(glm::vec3(0.65f, 0.65f, 0.61f), 1.f);
    sections[0].elements[1].button.color = glm::vec4(glm::vec3(0.43f, 0.4f, 0.39f), 1.f);
    sections[0].elements[2].button.color = glm::vec4(glm::vec3(0.29f, 0.22f, 0.17f), 1.f);
    sections[0].elements[3].button.color = glm::vec4(glm::vec3(0.49f, 0.3f, 0.2f), 1.f);
    

    return sections;
}

std::vector<Section> MaterialModifier::createSkinModifier(ColorPalette colorPalette)
{
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Droplets", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Droplets Count", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f), // /1
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Droplets Opacity Jitter", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Droplets Size", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 15.f), // /10
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Veins", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Veins Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f), // /1
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Veins Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 200.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Blushing", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Blushing Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 20.f), // /10
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Skin Prints", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Skin Prints Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f), // /1
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Skin Prints Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 200.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Noise", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Noise Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 20.f), // /10
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Skin Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_STYLIZED, glm::vec2(1, 1.5f), colorPalette, "Skin Color Type", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 5, 0 ), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Skin Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f), // /1
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Skin Wetness", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Skin Metallic", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 0.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Skin Height", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 200.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Skin Ambient Occlusion", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f),
                CheckBox(ELEMENT_STYLE_BASIC, glm::vec2(1.f, 2.f), colorPalette, "Blur the Height Map", MATERIAL_MODIFIERS_ELEMENT_OFFSET)
            }
        )
    };

    return sections;
}

std::vector<Section> MaterialModifier::createWoodenModifier(ColorPalette colorPalette)
{
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Colors", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Color 1", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Color 2", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Color 3", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f), // /10
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Noise Offset", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f), // /10
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Noise Seed", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 30.f), // *100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Perlin Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_STYLIZED, glm::vec2(1, 1.5f), colorPalette, "Max Octaves", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 8, 8 ), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Persistance", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 50.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Musgrave Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Musgrave Lacunarity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 25.f), // /10
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Musgrave Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 200.f, 75.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Musgrave Noise", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f), // /10
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Base", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Noise Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 46.f), // /10
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Color Saturation", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 200.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "FBM Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "FBM Frequency", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f), // /10
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Element Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Wood Gamma", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 60.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Shininess", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 200.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Metallic", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 0.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Height", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 0.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f),
                CheckBox(ELEMENT_STYLE_BASIC, glm::vec2(1.f, 2.f), colorPalette, "Blur the Height Map", MATERIAL_MODIFIERS_ELEMENT_OFFSET)
            }
        )
    };

    sections[0].elements[0].button.colorSelection = true;
    sections[0].elements[1].button.colorSelection = true;
    sections[0].elements[2].button.colorSelection = true;

    sections[0].elements[0].button.color = glm::vec4(glm::vec3(0.f), 1.f);
    sections[0].elements[1].button.color = glm::vec4(glm::vec3(0.25f, 0.11f, 0.04f), 1.f);
    sections[0].elements[2].button.color = glm::vec4(glm::vec3(0.52f, 0.32f, 0.19f), 1.f);


    return sections;
}

std::vector<Section> MaterialModifier::createAsphaltModifier(ColorPalette colorPalette){
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Color",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Color1",              Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false),
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Color2",              Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Dirt",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Scale",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,40.f), // /10
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Strength",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,200.f,100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"2nd Color",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Noise Scale",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,50.f), // /10
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Noise Strength",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,200.f,100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Noise",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Strength",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,200.f,100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Element Properties",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Wetness",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Metallic",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,0.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Height",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Perlin Properties",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_STYLIZED,glm::vec2(1,1.5f),colorPalette,"First Octave",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 8, 3 ),
                RangeBar(ELEMENT_STYLE_STYLIZED,glm::vec2(1,1.5f),colorPalette,"Octaves",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 8, 8 ), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Persistence",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,70.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f),
            }
        )
    };
    sections[0].elements[0].button.colorSelection = true;
    sections[0].elements[1].button.colorSelection = true;
    
    sections[0].elements[0].button.color = glm::vec4(glm::vec3(0.25f), 1.f);
    sections[0].elements[1].button.color = glm::vec4(glm::vec3(0.23f, 0.25f, 0.27f), 1.f);
    
    return sections;
}

std::vector<Section> MaterialModifier::createDustModifier(ColorPalette colorPalette){

    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Noise",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Size",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,10.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Offset Intensity",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,500.f,500.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Rotation",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,360.f,360.f), // /1
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Brightness",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,17.f), // /100
            }
        ),
        
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Blur",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Intensity",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,0.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Direction",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,360.f,0.f), // /1
            }
        ),
        
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Scratches",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Wavyness",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,10.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Scale",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,200.f,100.f), // /5
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Base Frequency",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,50.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"FrequencyStep",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,25.f), // /100
            }
        ),

        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Droplets",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Count",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,10.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"OpacityJitter",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Size",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,50.f), // /10
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),colorPalette,"Element Properties",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Wetness",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Metallic",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,0.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),colorPalette,"Height",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,100.f,100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), colorPalette, "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), colorPalette, "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f), // /100
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), colorPalette, "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 100.f),
                CheckBox(ELEMENT_STYLE_BASIC, glm::vec2(1.f, 2.f), colorPalette, "Blur the Height Map", MATERIAL_MODIFIERS_ELEMENT_OFFSET)
            }
        )
    };

    return sections;
}

void channelPrep(Material &material, Mesh &mesh, int& textureResolution, int& curModI, glm::mat4& perspective, glm::mat4& view, int& channelI, unsigned int& FBO, Texture& currentTexture, Texture& previousTexture, Texture& prevDepth){
    glDisable(GL_DEPTH_TEST);

    //Get the channel's texture from material
    
    if(channelI == 0){
        currentTexture = mesh.albedo;
    }
    if(channelI == 1){
        currentTexture = mesh.roughness;
    }
    if(channelI == 2){
        currentTexture = mesh.metallic;
    }
    if(channelI == 3){
        currentTexture = mesh.normalMap;
    }
    if(channelI == 4){
        currentTexture = mesh.heightMap;
    }
    if(channelI == 5){
        currentTexture = mesh.ambientOcclusion;
    }

    prevDepth = mesh.heightMap.duplicateTexture();

    /* ! Binds another framebuffer ! */
    previousTexture = currentTexture.duplicateTexture();

    //That framebuffer will be used to get the results of the shader 
    glGenFramebuffers(1,&FBO);
    glBindFramebuffer(GL_FRAMEBUFFER,FBO);

    //Bind the channel texture
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
    
    //Params for the channel texture
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_MIRRORED_REPEAT);
    
    //Refresh the channel texture
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, textureResolution, textureResolution, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
    glGenerateMipmap(GL_TEXTURE_2D);

    //Bind the channel texture to the capture framebuffer
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, currentTexture.ID, 0);
    
    glClearColor(0,0,0,1);
    glClear(GL_COLOR_BUFFER_BIT);
}

static void blurTheTexture(unsigned int& txtr, Mesh& mesh, int textureResolution){
    
    Texture textureObject = Texture(txtr);
    unsigned int textureCopy = textureObject.duplicateTexture();

    unsigned int FBO;
    glGenFramebuffers(1,&FBO);
    glBindFramebuffer(GL_FRAMEBUFFER,FBO);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, txtr, 0);
    glViewport(0, 0, textureResolution, textureResolution);

    glClearColor(0,0,0,0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    Box box;
    box.init();
    box.bindBuffers();
    
    glm::mat4 projection = glm::ortho(0.f, (float)textureResolution, (float)textureResolution, 0.f); 
    ShaderSystem::bluringShader().use();
    ShaderSystem::bluringShader().setInt("txtr", 0);
    ShaderSystem::bluringShader().setInt("uvMask", 1);
    ShaderSystem::bluringShader().setVec2("txtrRes", glm::vec2(textureResolution));
    ShaderSystem::bluringShader().setMat4("projection"  ,       projection);
    ShaderSystem::bluringShader().setMat4("projectedPosProjection"  ,       projection);
    ShaderSystem::bluringShader().setVec3("pos"         ,       glm::vec3((float)textureResolution / 2.f, (float)textureResolution / 2.f, 0.9f));
    ShaderSystem::bluringShader().setVec2("scale"       ,       glm::vec2((float)textureResolution / 2.f));

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, textureCopy);
    
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, mesh.uvMask);

    glDrawArrays(GL_TRIANGLES, 0 , 6);

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    
    glDeleteFramebuffers(1, &FBO);
    glDeleteTextures(1, &textureCopy);
}

glm::vec2 getDirectionVector(float rotation) {
  // Convert rotation from degrees to radians
  float radians = glm::radians(rotation);

  // Calculate the x and y components of the direction vector
  float x = glm::cos(radians);
  float y = glm::sin(radians);

  return glm::vec2(x, y);
}


void textureModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view){

    //Set the OpenGL viewport to the texture resolution
    glViewport(0,0,textureResolution,textureResolution);

    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);
    
    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    Scene scene;
    scene.projectionMatrix = perspective;
    scene.viewMatrix = view;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, scene, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, perspective, view, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);

        //Set the uniforms of the modifier's shader
        material.materialModifiers[curModI].shader.use(); //Use the shader of the modifier
        material.materialModifiers[curModI].shader.setMat4("orthoProjection",projection); //Set the projection
        material.materialModifiers[curModI].shader.setMat4("perspectiveProjection",perspective); //Set the projection
        material.materialModifiers[curModI].shader.setMat4("view",view); //Set the projection        
        material.materialModifiers[curModI].shader.setInt("state",channelI); //Set the texture slot
        material.materialModifiers[curModI].shader.setInt("theTexture",0); //Set the texture slot
        material.materialModifiers[curModI].shader.setInt("mask", 1); //Set the texture slot
        material.materialModifiers[curModI].shader.setInt("previousTxtr", 2); //Set the texture slot
        material.materialModifiers[curModI].shader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[channelI].rangeBar.value / 100.f); 
        material.materialModifiers[curModI].shader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].rangeBar.value / 100.f); 
        material.materialModifiers[curModI].shader.setInt( "depthTxtr" , 3);

        //Bind the texture (bind the channel textures if rendering a texture modifier & bind the result of the previous modifier)
        glActiveTexture(GL_TEXTURE0);
        unsigned int proceduralChannelTexture = 0;
        proceduralChannelTexture = material.materialModifiers[curModI].sections[0].elements[channelI].button.texture.generateProceduralTexture(mesh, scene, textureResolution);

        material.materialModifiers[curModI].shader.use();
        glBindFramebuffer(GL_FRAMEBUFFER, FBO);
        glBindTexture(GL_TEXTURE_2D, proceduralChannelTexture);
    
        // Bind the mask texture
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);

        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        glActiveTexture(GL_TEXTURE3);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);

        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        glDeleteTextures(1, &previousTexture.ID);
        if(material.materialModifiers[curModI].sections[0].elements[channelI].button.texture.proceduralID != -1)
            glDeleteTextures(1, &proceduralChannelTexture);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void dustModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view){

    Shader modifierShader = material.materialModifiers[curModI].shader;

    //Set the OpenGL viewport to the texture resolution
    glViewport(0,0,textureResolution,textureResolution);

    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    Scene scene;
    scene.projectionMatrix = perspective;
    scene.viewMatrix = view;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, scene, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, perspective, view, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setMat4("perspectiveProjection",perspective); //Set the projection
        modifierShader.setMat4("view",view); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[channelI].rangeBar.value / 100.f);
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].rangeBar.value / 100.f);
        modifierShader.setInt( "depthTxtr" , 2);

        /* Noise */
        modifierShader.setFloat("size", material.materialModifiers[curModI].sections[0].elements[0].rangeBar.value / 100.f); 
        modifierShader.setFloat("offsetIntensity", material.materialModifiers[curModI].sections[0].elements[1].rangeBar.value / 10.f); 
        modifierShader.setFloat("rotation", material.materialModifiers[curModI].sections[0].elements[2].rangeBar.value); 
        modifierShader.setFloat("brightness", material.materialModifiers[curModI].sections[0].elements[3].rangeBar.value / 100.f); 
        /* Blur */
        modifierShader.setFloat("blurIntensity", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value / 100.f);
        modifierShader.setVec2("blurDirection", getDirectionVector(material.materialModifiers[curModI].sections[1].elements[1].rangeBar.value));
        /* Scratches */
        modifierShader.setFloat("scratchesWavyness", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value / 100.f); 
        modifierShader.setVec2("scratchesScale", glm::vec2(material.materialModifiers[curModI].sections[2].elements[1].rangeBar.value / 5.f));
        modifierShader.setVec2("scratchesBaseFrequency", glm::vec2(material.materialModifiers[curModI].sections[2].elements[2].rangeBar.value / 100.f));
        modifierShader.setVec2("scratchesFrequencyStep", glm::vec2(material.materialModifiers[curModI].sections[2].elements[3].rangeBar.value / 100.f));
        /* Droplets */
        modifierShader.setFloat("dropletsCount", material.materialModifiers[curModI].sections[3].elements[0].rangeBar.value / 100.f); 
        modifierShader.setFloat("dropletsOpacityJitter", material.materialModifiers[curModI].sections[3].elements[1].rangeBar.value / 100.f);
        modifierShader.setFloat("dropletsSize", material.materialModifiers[curModI].sections[3].elements[2].rangeBar.value / 10.f);

        /* Element property */
        modifierShader.setFloat("wetness", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value / 100.f);
        modifierShader.setFloat("metallic", material.materialModifiers[curModI].sections[4].elements[1].rangeBar.value / 100.f);
        modifierShader.setFloat("height", material.materialModifiers[curModI].sections[4].elements[2].rangeBar.value / 100.f);
        

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);

        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);

        //Generating the normal map
        if(channelI == 4){
            if(material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size() - 1].elements[1].checkBox.clickState1)
                blurTheTexture(mesh.heightMap.ID, mesh, textureResolution);
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }

        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void solidModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view){

    Shader modifierShader = material.materialModifiers[curModI].shader;

    //Set the OpenGL viewport to the texture resolution
    glViewport(0,0,textureResolution,textureResolution);

    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    Scene scene;
    scene.projectionMatrix = perspective;
    scene.viewMatrix = view;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, scene, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, perspective, view, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",perspective); //Set the projection
        modifierShader.setMat4("view",view); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state",channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[0].elements[channelI * 2 + 1].rangeBar.value / 100.f); //Set the channel opacity
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].rangeBar.value / 100.f); 
        modifierShader.setInt( "depthTxtr" , 2); //Set the channel opacity
        modifierShader.setVec3( "value" , glm::vec3(
                                                        material.materialModifiers[curModI].sections[0].elements[channelI * 2].button.color.r, 
                                                        material.materialModifiers[curModI].sections[0].elements[channelI * 2].button.color.g, 
                                                        material.materialModifiers[curModI].sections[0].elements[channelI * 2].button.color.b
                                                    )); //Set the channel color value

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);

        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void asphaltModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view){

    Shader modifierShader = material.materialModifiers[curModI].shader;


    //Set the OpenGL viewport to the texture resolution
    glViewport(0,0,textureResolution,textureResolution);

    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    Scene scene;
    scene.projectionMatrix = perspective;
    scene.viewMatrix = view;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, scene, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, perspective, view, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",perspective); //Set the projection
        modifierShader.setMat4("view",view); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[channelI].rangeBar.value / 100.f); 
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].rangeBar.value / 100.f); 
        modifierShader.setInt( "depthTxtr" , 2);

        /* Colors */
        modifierShader.setVec3("asphaltColor", material.materialModifiers[curModI].sections[0].elements[0].button.color);
        modifierShader.setVec3("asphaltColor2", material.materialModifiers[curModI].sections[0].elements[1].button.color);

        /* Dirt */
        modifierShader.setFloat("dirtScale", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value / 10.f);
        modifierShader.setFloat("dirtStrength", material.materialModifiers[curModI].sections[1].elements[1].rangeBar.value / 100.f);

        /* 2nd Color */
        modifierShader.setFloat("colorNoiseScale", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value / 10.f);
        modifierShader.setFloat("colorNoiseStrength", material.materialModifiers[curModI].sections[2].elements[1].rangeBar.value / 100.f);

        /* Noise */ 
        modifierShader.setFloat("noiseStrength", material.materialModifiers[curModI].sections[3].elements[0].rangeBar.value / 100.f);

        /* Element property */
        modifierShader.setFloat("wetness", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value / 100.f);
        modifierShader.setFloat("metallic", material.materialModifiers[curModI].sections[4].elements[1].rangeBar.value / 100.f);
        modifierShader.setFloat("height", material.materialModifiers[curModI].sections[4].elements[2].rangeBar.value / 100.f);

        /* Perlin Noise Properties*/
        modifierShader.setInt("firstOctave", material.materialModifiers[curModI].sections[5].elements[0].rangeBar.value);
        modifierShader.setInt("octaves", material.materialModifiers[curModI].sections[5].elements[1].rangeBar.value); 
        modifierShader.setFloat("persistence", material.materialModifiers[curModI].sections[5].elements[2].rangeBar.value / 100.f); 

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        
        //Generating the normal map
        if(channelI == 4){
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void fabricModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view){

    Shader modifierShader = material.materialModifiers[curModI].shader;


    //Set the OpenGL viewport to the texture resolution
    glViewport(0,0,textureResolution,textureResolution);

    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    Scene scene;
    scene.projectionMatrix = perspective;
    scene.viewMatrix = view;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, scene, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, perspective, view, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",perspective); //Set the projection
        modifierShader.setMat4("view",view); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[channelI].rangeBar.value / 100.f); 
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].rangeBar.value / 100.f); 
        modifierShader.setInt( "depthTxtr" , 2);

        /* Stripes */
        modifierShader.setVec3("color", material.materialModifiers[curModI].sections[0].elements[0].button.color);
        modifierShader.setFloat("scale", material.materialModifiers[curModI].sections[0].elements[1].rangeBar.value / 1.f);
        modifierShader.setFloat("stripeFrequency", material.materialModifiers[curModI].sections[0].elements[2].rangeBar.value / 2.f);
        modifierShader.setFloat("gapFrequency", material.materialModifiers[curModI].sections[0].elements[3].rangeBar.value / 2.f);
        modifierShader.setInt("style", material.materialModifiers[curModI].sections[0].elements[4].rangeBar.value);

        /* Element property */
        modifierShader.setFloat("wetness", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value / 100.f);
        modifierShader.setFloat("metallic", material.materialModifiers[curModI].sections[1].elements[1].rangeBar.value / 100.f);
        modifierShader.setFloat("height", material.materialModifiers[curModI].sections[1].elements[2].rangeBar.value / 100.f);


        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        
        //Generating the normal map
        if(channelI == 4){
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}


void woodenModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view){

    Shader modifierShader = material.materialModifiers[curModI].shader;


    //Set the OpenGL viewport to the texture resolution
    glViewport(0,0,textureResolution,textureResolution);

    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    Scene scene;
    scene.projectionMatrix = perspective;
    scene.viewMatrix = view;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, scene, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, perspective, view, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",perspective); //Set the projection
        modifierShader.setMat4("view",view); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[channelI].rangeBar.value / 100.f); 
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].rangeBar.value / 100.f); 
        modifierShader.setInt( "depthTxtr" , 2);

        /* Colors */
        modifierShader.setVec3("woodColor1", material.materialModifiers[curModI].sections[0].elements[0].button.color);
        modifierShader.setVec3("woodColor2", material.materialModifiers[curModI].sections[0].elements[1].button.color);
        modifierShader.setVec3("woodColor3", material.materialModifiers[curModI].sections[0].elements[2].button.color);

        /* Properties */
        modifierShader.setFloat("scale", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value / 10.f);
        modifierShader.setFloat("noiseOffset", material.materialModifiers[curModI].sections[1].elements[1].rangeBar.value / 10.f);
        modifierShader.setFloat("seed", material.materialModifiers[curModI].sections[1].elements[2].rangeBar.value * 100.f);

        /* Perlin Properties */
        modifierShader.setInt("maxOctaves", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value); 
        modifierShader.setFloat("persistance", material.materialModifiers[curModI].sections[2].elements[1].rangeBar.value / 100.f);

        /* Musgrave Properties */
        modifierShader.setFloat("musgraveLacunarity", material.materialModifiers[curModI].sections[3].elements[0].rangeBar.value / 10.f);
        modifierShader.setFloat("musgraveStrength", material.materialModifiers[curModI].sections[3].elements[1].rangeBar.value / 100.f);
        modifierShader.setFloat("musgraveNoise", material.materialModifiers[curModI].sections[3].elements[2].rangeBar.value / 10.f);

        /* Base */
        modifierShader.setFloat("baseNoiseStrength", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value / 10.f);
        modifierShader.setFloat("baseColorSaturation", material.materialModifiers[curModI].sections[4].elements[1].rangeBar.value / 100.f);

        /* FBM Properties */
        modifierShader.setFloat("fbmFrequency", material.materialModifiers[curModI].sections[5].elements[0].rangeBar.value / 10.f);

        /* Element property */
        modifierShader.setFloat("woodGamma", material.materialModifiers[curModI].sections[6].elements[0].rangeBar.value / 100.f);
        modifierShader.setFloat("shininess", material.materialModifiers[curModI].sections[6].elements[1].rangeBar.value / 100.f);
        modifierShader.setFloat("metallic", material.materialModifiers[curModI].sections[6].elements[2].rangeBar.value / 100.f);
        modifierShader.setFloat("height", material.materialModifiers[curModI].sections[6].elements[3].rangeBar.value / 100.f);

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        
        //Generating the normal map
        if(channelI == 4){
            if(material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size() - 1].elements[1].checkBox.clickState1)
                blurTheTexture(mesh.heightMap.ID, mesh, textureResolution);
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void mossModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view){

    Shader modifierShader = material.materialModifiers[curModI].shader;


    //Set the OpenGL viewport to the texture resolution
    glViewport(0,0,textureResolution,textureResolution);

    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    Scene scene;
    scene.projectionMatrix = perspective;
    scene.viewMatrix = view;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, scene, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, perspective, view, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",perspective); //Set the projection
        modifierShader.setMat4("view",view); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[channelI].rangeBar.value / 100.f); 
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].rangeBar.value / 100.f); 
        modifierShader.setInt( "depthTxtr" , 2);

        /* Color */
        modifierShader.setVec3("mossColorBack", material.materialModifiers[curModI].sections[0].elements[0].button.color);
        modifierShader.setVec3("mossColorFront", material.materialModifiers[curModI].sections[0].elements[1].button.color);
        modifierShader.setVec3("dirtColor", material.materialModifiers[curModI].sections[0].elements[2].button.color);

        /* Droplets */
        modifierShader.setFloat("dropletsCount", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value / 1.f);
        modifierShader.setFloat("dropletsOpacityJitter", material.materialModifiers[curModI].sections[1].elements[1].rangeBar.value / 100.f);
        modifierShader.setFloat("dropletsSize", material.materialModifiers[curModI].sections[1].elements[2].rangeBar.value / 10.f);

        /* Front Layer */
        modifierShader.setFloat("frontLayerStrength", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value / 100.f);
        modifierShader.setFloat("frontLayerScale", material.materialModifiers[curModI].sections[2].elements[1].rangeBar.value / 100.f);

        /* Lighting */
        modifierShader.setFloat("lightStrength", material.materialModifiers[curModI].sections[3].elements[0].rangeBar.value / 100.f);
        modifierShader.setFloat("darkeningStrength", material.materialModifiers[curModI].sections[3].elements[1].rangeBar.value / 100.f);

        /* Noise */
        modifierShader.setFloat("noiseStrength", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value / 100.f);

        /* Moss Properties*/
        modifierShader.setFloat("scale", material.materialModifiers[curModI].sections[5].elements[0].rangeBar.value / 1.f);

        /* Element property */
        modifierShader.setFloat("wetness", material.materialModifiers[curModI].sections[6].elements[0].rangeBar.value / 100.f);
        modifierShader.setFloat("metallic", material.materialModifiers[curModI].sections[6].elements[1].rangeBar.value / 100.f);
        modifierShader.setFloat("height", material.materialModifiers[curModI].sections[6].elements[2].rangeBar.value / 100.f);

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        
        //Generating the normal map
        if(channelI == 4){
            if(material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size() - 1].elements[1].checkBox.clickState1)
                blurTheTexture(mesh.heightMap.ID, mesh, textureResolution);
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void rustModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view){

    Shader modifierShader = material.materialModifiers[curModI].shader;


    //Set the OpenGL viewport to the texture resolution
    glViewport(0,0,textureResolution,textureResolution);

    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    Scene scene;
    scene.projectionMatrix = perspective;
    scene.viewMatrix = view;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, scene, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, perspective, view, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",perspective); //Set the projection
        modifierShader.setMat4("view",view); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[channelI].rangeBar.value / 100.f); 
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].rangeBar.value / 100.f); 
        modifierShader.setInt( "depthTxtr" , 2);

        /* Colors */
        modifierShader.setVec3("color1", material.materialModifiers[curModI].sections[0].elements[0].button.color);
        modifierShader.setVec3("color2", material.materialModifiers[curModI].sections[0].elements[1].button.color);
        modifierShader.setVec3("color3", material.materialModifiers[curModI].sections[0].elements[2].button.color);
        modifierShader.setVec3("color4", material.materialModifiers[curModI].sections[0].elements[3].button.color);

        /*Properties*/
        modifierShader.setFloat("scale", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value / 1.f);

        /* Perlin Properties */
        modifierShader.setInt("firstOctave", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value); 
        modifierShader.setInt("octaves", material.materialModifiers[curModI].sections[2].elements[1].rangeBar.value);
        modifierShader.setFloat("persistence", material.materialModifiers[curModI].sections[2].elements[2].rangeBar.value / 100.f); 

        /* FBM Properties*/
        modifierShader.setInt("fbmOctaves", material.materialModifiers[curModI].sections[3].elements[0].rangeBar.value); 
        modifierShader.setFloat("fbmRoughness", material.materialModifiers[curModI].sections[3].elements[1].rangeBar.value / 100.f);

        /* Rust Properties */
        modifierShader.setFloat("rustRadius", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value / 10.f);
        modifierShader.setFloat("batteringStrength", material.materialModifiers[curModI].sections[4].elements[1].rangeBar.value / 100.f);

        /* Noise Properties*/
        modifierShader.setFloat("noiseStrength", material.materialModifiers[curModI].sections[5].elements[0].rangeBar.value / 100.f);

        /* Element property */
        modifierShader.setFloat("wetness", material.materialModifiers[curModI].sections[6].elements[0].rangeBar.value / 100.f);
        modifierShader.setFloat("metallic", material.materialModifiers[curModI].sections[6].elements[1].rangeBar.value / 100.f);
        modifierShader.setFloat("height", material.materialModifiers[curModI].sections[6].elements[2].rangeBar.value / 100.f);

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        
        //Generating the normal map
        if(channelI == 4){
            if(material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size() - 1].elements[1].checkBox.clickState1)
                blurTheTexture(mesh.heightMap.ID, mesh, textureResolution);
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void skinModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI, glm::mat4 perspective, glm::mat4 view){

    Shader modifierShader = material.materialModifiers[curModI].shader;
    
    //Set the OpenGL viewport to the texture resolution
    glViewport(0,0,textureResolution,textureResolution);

    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    Scene scene;
    scene.projectionMatrix = perspective;
    scene.viewMatrix = view;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, scene, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, perspective, view, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",perspective); //Set the projection
        modifierShader.setMat4("view",view); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[channelI].rangeBar.value / 100.f); 
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].rangeBar.value / 100.f); 
        modifierShader.setInt( "depthTxtr" , 2);

        /* Droplets */
        modifierShader.setFloat("dropletsCount", material.materialModifiers[curModI].sections[0].elements[0].rangeBar.value / 1.f);
        modifierShader.setFloat("dropletsOpacityJitter", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value / 100.f);
        modifierShader.setFloat("dropletsSize", material.materialModifiers[curModI].sections[0].elements[2].rangeBar.value / 10.f);

        /* Veins */
        modifierShader.setFloat("veinsScale", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value / 1.f);
        modifierShader.setFloat("veinsStrength", material.materialModifiers[curModI].sections[1].elements[1].rangeBar.value / 100.f);

        /* Blushing */
        modifierShader.setFloat("blushingStrength", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value / 10.f);

        /* Skin Prints */
        modifierShader.setFloat("skinPrintsScale", material.materialModifiers[curModI].sections[3].elements[0].rangeBar.value / 1.f);
        modifierShader.setFloat("skinPrintsStrength", material.materialModifiers[curModI].sections[3].elements[1].rangeBar.value / 100.f);

        /* Noise */
        modifierShader.setFloat("noiseStrength", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value / 10.f);

        /* Skin Properties*/
        modifierShader.setInt("skinColorType", material.materialModifiers[curModI].sections[5].elements[0].rangeBar.value);
        modifierShader.setFloat("skinScale", material.materialModifiers[curModI].sections[5].elements[1].rangeBar.value / 1.f);
        modifierShader.setFloat("skinWetness", material.materialModifiers[curModI].sections[5].elements[2].rangeBar.value / 100.f);
        modifierShader.setFloat("skinMetallic", material.materialModifiers[curModI].sections[5].elements[3].rangeBar.value / 100.f);
        modifierShader.setFloat("skinHeight", material.materialModifiers[curModI].sections[5].elements[4].rangeBar.value / 100.f);
        modifierShader.setFloat("skinAmbientOcclusion", material.materialModifiers[curModI].sections[5].elements[5].rangeBar.value / 100.f);

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        
        //Generating the normal map
        if(channelI == 4){
            if(material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size() - 1].elements[1].checkBox.clickState1)
                blurTheTexture(mesh.heightMap.ID, mesh, textureResolution);
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}