/*
---------------------------------------------------------------------------
LigidPainter - 3D Model texturing software / Texture generator   
---------------------------------------------------------------------------

Copyright (c) 2022-2023, Mert Tetik

All rights reserved.

Official GitHub Link : https://github.com/mert-tetik/LigidPainter
Official Web Page : https://ligidtools.com/ligidpainter

---------------------------------------------------------------------------
*/

#include<glad/glad.h>
#include "LigidGL/LigidGL.hpp"

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include <glm/gtc/type_ptr.hpp>

#include <string>
#include <iostream>
#include <vector>

#include "GUI/Elements/Elements.hpp"
#include "UTIL/Util.hpp"
#include "3D/ThreeD.hpp"
#include "ShaderSystem/Shader.hpp"
#include "SettingsSystem/Settings.hpp"

//0 = albedo
//1 = roughness
//2 = metallic 
//3 = normal map
//4 = height map
//5 = ambient Occlusion

MaterialModifier::MaterialModifier(){}

void textureModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI);
void dustModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI);
void solidModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI);
void asphaltModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI);
void liquidModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI);
void woodenModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI);
void mossModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI);
void rustModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI);
void skinModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI);

MaterialModifier::MaterialModifier(int modifierIndex){    
    
    /* Init the mask texture */
    this->maskTexture.proceduralID = 24; //Solid white
    this->maskTexture.proceduralnverted = 0;
    this->maskTexture.proceduralScale = 1.f;
    this->maskTexture.title = "AutoGeneratedMask";

    // Create a 1x1 pixel white texture for the procedural texture displaying
    unsigned char whitePixel[] = { 255, 255, 255, 255 }; // 1 pixel, RGBA format (white)
    glGenTextures(1, &this->maskTexture.ID);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, this->maskTexture.ID);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, whitePixel);

    // Set texture parameters 
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_MIRRORED_REPEAT);

    glBindTexture(GL_TEXTURE_2D, 0);

    if(modifierIndex == TEXTURE_MATERIAL_MODIFIER){
        this->sections = createTextureModifier();

        this->title = "Texture Modifier";    
        this->shader.loadShaderPP("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/TextureModifier.frag");
        this->updateMaterialChannels = textureModifierUpdateMat;
    }
    else if(modifierIndex == DUST_MATERIAL_MODIFIER){
        this->sections = createDustModifier();
        this->title = "Dust Modifier";    
        this->shader.loadShaderPP("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/DustModifier.frag");
        this->updateMaterialChannels = dustModifierUpdateMat;
    }
    else if(modifierIndex == ASPHALT_MATERIAL_MODIFIER){
        this->sections = createAsphaltModifier();
        this->title = "Asphalt Modifier";    
        this->shader.loadShaderPP("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/AsphaltModifier.frag");
        this->updateMaterialChannels = asphaltModifierUpdateMat;
    }
    else if(modifierIndex == LIQUID_MATERIAL_MODIFIER){
        this->sections = createLiquidModifier();
        this->title = "Liquid Modifier";    
        this->shader.loadShaderPP("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/LiquidModifier.frag");
        this->updateMaterialChannels = liquidModifierUpdateMat;
    }
    else if(modifierIndex == MOSS_MATERIAL_MODIFIER){
        this->sections = createMossModifier();
        this->title = "Moss Modifier";    
        this->shader.loadShaderPP("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/MossModifier.frag");
        this->updateMaterialChannels = mossModifierUpdateMat;
    }
    else if(modifierIndex == RUST_MATERIAL_MODIFIER){
        this->sections = createRustModifier();
        this->title = "Rust Modifier";    
        this->shader.loadShaderPP("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/RustModifier.frag");
        this->updateMaterialChannels = rustModifierUpdateMat;
    }
    else if(modifierIndex == SKIN_MATERIAL_MODIFIER){
        this->sections = createSkinModifier();
        this->title = "Skin Modifier";    
        this->shader.loadShaderPP("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/SkinModifier.frag");
        this->updateMaterialChannels = skinModifierUpdateMat;
    }
    else if(modifierIndex == SOLID_MATERIAL_MODIFIER){
        this->sections = createSolidModifier();
        this->title = "Solid Modifier";    
        this->shader.loadShaderPP("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/SolidModifier.frag");
        this->updateMaterialChannels = solidModifierUpdateMat;
    }
    else if(modifierIndex == WOODEN_MATERIAL_MODIFIER){
        this->sections = createWoodenModifier();
        this->title = "Wooden Modifier";    
        this->shader.loadShaderPP("LigidPainter/Resources/Shaders/aVert/2D_model_UV.vert","LigidPainter/Resources/Shaders/MaterialModifiers/WoodenModifier.frag");
        this->updateMaterialChannels = woodenModifierUpdateMat;
    }

    this->modifierIndex = modifierIndex;
}

#define MATERIAL_MODIFIERS_ELEMENT_OFFSET 2.5f

std::vector<Section> MaterialModifier::createTextureModifier(){
        
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Channels",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Albedo",              Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false)),
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Roughness",           Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false)),
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Metallic",            Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false)),
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Normal map",          Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false)),
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Height map",          Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false)),
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Ambient Occlusion",   Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false))
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
            }
        ),
        Section(
            Element(Button()),
            {
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f), "Albedo Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.f), "Remove The Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)
            }
        )
    };

    sections[0].elements[0].button.textureSelection = true;
    sections[0].elements[1].button.textureSelection = true;
    sections[0].elements[2].button.textureSelection = true;
    sections[0].elements[3].button.textureSelection = true;
    sections[0].elements[4].button.textureSelection = true;
    sections[0].elements[5].button.textureSelection = true;

    sections[sections.size() - 1].elements[0].button.filterSelection = true;
    
    return sections;
}

std::vector<Section> MaterialModifier::createSolidModifier(){
        
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Channels",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Albedo",              Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Roughness",           Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Metallic",            Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Normal Map",          Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Height map",          Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                
                Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Ambient Occlusion",   Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f ) 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                CheckBox(ELEMENT_STYLE_BASIC, glm::vec2(1.f, 2.f), "Blur the Height Map", MATERIAL_MODIFIERS_ELEMENT_OFFSET)
            }
        ),
        Section(
            Element(Button()),
            {
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f), "Albedo Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.f), "Remove The Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)
            }
        )
    };

    sections[0].elements[0].button.colorSelection = true;
    sections[0].elements[2].button.colorSelection = true;
    sections[0].elements[4].button.colorSelection = true;
    sections[0].elements[6].button.colorSelection = true;
    sections[0].elements[6].button.color = glm::vec4(0.5f,0.5f,1.f,1.f);
    sections[0].elements[8].button.colorSelection = true;
    sections[0].elements[10].button.colorSelection = true;

    sections[sections.size() - 1].elements[0].button.filterSelection = true;
    
    return sections;
}

std::vector<Section> MaterialModifier::createLiquidModifier(){
    
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1,2.f),"Scaling",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f), "Scale", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 50.f, 6.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f), "Scale Y axis", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 1.f)
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Noise",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_STYLIZED, glm::vec2(1,1.5f),"Octaves",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 12, 8),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f),"Fbm X Offset",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 0.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f),"Fbm Y Offset",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 7.7f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f),"Fbm X Scale",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 5.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f),"Fbm Y Scale",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 5.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f),"Roughness",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.2f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f),"Frequency Acceleration",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 6.f, 2.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f),"Fbm Total",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, -1.f, 1.f, 0.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f),"Seed",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.3f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f), "General", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f), "Noise Influence", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 6.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f), "Position Influence", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 1.8f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f), "Colors", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f), "Color1", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f), "Color2", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f), "Color3", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f), "Color4", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f), "Element Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f), "Wetness", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.6f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f), "Metallic", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f), "Height", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1,1.5f), "Ambient Occlusion", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f)
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
            }
        ),
        Section(
            Element(Button()),
            {
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f), "Albedo Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.f), "Remove The Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)
            }
        )
    };
    sections[3].elements[0].button.colorSelection = true;
    sections[3].elements[0].button.color = glm::vec4(glm::vec3(0.23f, 0.25f, 0.24f), 1.f);
    sections[3].elements[1].button.colorSelection = true;
    sections[3].elements[1].button.color = glm::vec4(glm::vec3(0.62f, 0.71f, 0.70f), 1.f);
    sections[3].elements[2].button.colorSelection = true;
    sections[3].elements[2].button.color = glm::vec4(glm::vec3(0.85f, 0.94f, 0.93f), 1.f);
    sections[3].elements[3].button.colorSelection = true;
    sections[3].elements[3].button.color = glm::vec4(glm::vec3(0.58f, 0.82f, 0.75f), 1.f);

    sections[sections.size() - 1].elements[0].button.filterSelection = true;
    
    return sections;
} 

std::vector<Section> MaterialModifier::createMossModifier()
{
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Color", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Moss Color Back", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Moss Color Front", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Dirt Color", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Droplets", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Droplets Count", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Droplets Opacity Jitter", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Droplets Size", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 1.5f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Front Layer", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Front Layer Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Front Layer Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 2.f, 0.5f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Lighting", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Light Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 2.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Darkening Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 2.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Noise", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Noise Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 2.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Moss Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Element Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Wetness", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.4f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Metallic", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Height", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                CheckBox(ELEMENT_STYLE_BASIC, glm::vec2(1.f, 2.f), "Blur the Height Map", MATERIAL_MODIFIERS_ELEMENT_OFFSET)
            }
        ),
        Section(
            Element(Button()),
            {
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f), "Albedo Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.f), "Remove The Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)
            }
        )
    };

    sections[0].elements[0].button.colorSelection = true;
    sections[0].elements[1].button.colorSelection = true;
    sections[0].elements[2].button.colorSelection = true;

    sections[0].elements[0].button.color = glm::vec4(glm::vec3(0.19f, 0.19f, 0.13f), 1.f);
    sections[0].elements[1].button.color = glm::vec4(glm::vec3(0.21f, 0.27f, 0.01f), 1.f);
    sections[0].elements[2].button.color = glm::vec4(glm::vec3(0.27f, 0.22f, 0.15f), 1.f);
    

    sections[sections.size() - 1].elements[0].button.filterSelection = true;
    
    return sections;
}

std::vector<Section> MaterialModifier::createRustModifier()
{
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Colors", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Color 1", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Color 2", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Color 3", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Color 4", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 30.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Perlin Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_STYLIZED, glm::vec2(1, 1.5f), "First Octave", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 8, 3 ), 
                RangeBar(ELEMENT_STYLE_STYLIZED, glm::vec2(1, 1.5f), "Octaves", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 8, 8 ), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Persistence", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.6f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "FBM Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_STYLIZED, glm::vec2(1, 1.5f), "FBM Octaves", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 16, 16 ), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "FBM Roughness", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.5f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Rust Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Rust Radius", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 2.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Battering Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 2.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Noise Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Noise Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 2.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Element Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Wetness", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Metallic", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Height", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                CheckBox(ELEMENT_STYLE_BASIC, glm::vec2(1.f, 2.f), "Blur the Height Map", MATERIAL_MODIFIERS_ELEMENT_OFFSET)
            }
        ),
        Section(
            Element(Button()),
            {
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f), "Albedo Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.f), "Remove The Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)
            }
        )
    };
    
    sections[0].elements[0].button.colorSelection = true;
    sections[0].elements[1].button.colorSelection = true;
    sections[0].elements[2].button.colorSelection = true;
    sections[0].elements[3].button.colorSelection = true;

    sections[0].elements[0].button.color = glm::vec4(glm::vec3(0.65f, 0.65f, 0.61f), 1.f);
    sections[0].elements[1].button.color = glm::vec4(glm::vec3(0.43f, 0.4f, 0.39f), 1.f);
    sections[0].elements[2].button.color = glm::vec4(glm::vec3(0.29f, 0.22f, 0.17f), 1.f);
    sections[0].elements[3].button.color = glm::vec4(glm::vec3(0.49f, 0.3f, 0.2f), 1.f);
    

    sections[sections.size() - 1].elements[0].button.filterSelection = true;
    
    return sections;
}

std::vector<Section> MaterialModifier::createSkinModifier()
{
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Droplets", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Droplets Count", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Droplets Opacity Jitter", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Droplets Size", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 1.5f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Veins", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Veins Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Veins Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 2.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Blushing", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Blushing Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 2.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Skin Prints", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Skin Prints Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Skin Prints Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 2.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Noise", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Noise Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 2.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Skin Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_STYLIZED, glm::vec2(1, 1.5f), "Skin Color Type", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 5, 0 ), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Skin Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 100.f, 10.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Skin Wetness", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Skin Metallic", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Skin Height", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 2.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Skin Ambient Occlusion", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                CheckBox(ELEMENT_STYLE_BASIC, glm::vec2(1.f, 2.f), "Blur the Height Map", MATERIAL_MODIFIERS_ELEMENT_OFFSET)
            }
        ),
        Section(
            Element(Button()),
            {
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f), "Albedo Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.f), "Remove The Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)
            }
        )
    };

    sections[sections.size() - 1].elements[0].button.filterSelection = true;
    
    return sections;
}

std::vector<Section> MaterialModifier::createWoodenModifier()
{
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Colors", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Color 1", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Color 2", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Color 3", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Scale", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Noise Offset", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Noise Seed", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10000.f, 3000.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Perlin Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_STYLIZED, glm::vec2(1, 1.5f), "Max Octaves", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 8, 8 ), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Persistance", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.5f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Musgrave Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Musgrave Lacunarity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 2.5f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Musgrave Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 2.f, 0.75f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Musgrave Noise", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Base", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Noise Strength", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 4.6f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Color Saturation", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 2.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "FBM Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "FBM Frequency", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 10.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Element Properties", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Wood Gamma", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.6f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Shininess", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 2.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Metallic", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Height", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                CheckBox(ELEMENT_STYLE_BASIC, glm::vec2(1.f, 2.f), "Blur the Height Map", MATERIAL_MODIFIERS_ELEMENT_OFFSET)
            }
        ),
        Section(
            Element(Button()),
            {
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f), "Albedo Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.f), "Remove The Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)
            }
        )
    };

    sections[0].elements[0].button.colorSelection = true;
    sections[0].elements[1].button.colorSelection = true;
    sections[0].elements[2].button.colorSelection = true;

    sections[0].elements[0].button.color = glm::vec4(glm::vec3(0.f), 1.f);
    sections[0].elements[1].button.color = glm::vec4(glm::vec3(0.25f, 0.11f, 0.04f), 1.f);
    sections[0].elements[2].button.color = glm::vec4(glm::vec3(0.52f, 0.32f, 0.19f), 1.f);


    sections[sections.size() - 1].elements[0].button.filterSelection = true;
    
    return sections;
}

std::vector<Section> MaterialModifier::createAsphaltModifier(){
    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Color",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Color1",              Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false),
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Color2",              Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,false),
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Dirt",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Scale",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 10.f,4.f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Strength",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,2.f,1.f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"2nd Color",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Noise Scale",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,10.f,5.f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Noise Strength",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,2.f,1.f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Noise",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Strength",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,2.f,1.f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Element Properties",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Wetness",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,1.f,1.f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Metallic",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,1.f,0.f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Height",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,1.f,1.f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Perlin Properties",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_STYLIZED,glm::vec2(1,1.5f),"First Octave",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 8, 3 ),
                RangeBar(ELEMENT_STYLE_STYLIZED,glm::vec2(1,1.5f),"Octaves",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0, 8, 8 ), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Persistence",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.7f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
            }
        ),
        Section(
            Element(Button()),
            {
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f), "Albedo Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.f), "Remove The Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)
            }
        )
    };
    sections[0].elements[0].button.colorSelection = true;
    sections[0].elements[1].button.colorSelection = true;
    
    sections[0].elements[0].button.color = glm::vec4(glm::vec3(0.25f), 1.f);
    sections[0].elements[1].button.color = glm::vec4(glm::vec3(0.23f, 0.25f, 0.27f), 1.f);
    
    sections[sections.size() - 1].elements[0].button.filterSelection = true;
    
    return sections;
}

std::vector<Section> MaterialModifier::createDustModifier(){

    std::vector<Section> sections =  
    {
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Noise",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Size",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 1.f, 0.1f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Offset Intensity",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 5.f, 5.f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Rotation",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 360.f, 360.f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Brightness",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 1.f, 0.17f), 
            }
        ),
        
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Blur",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Intensity",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 1.f, 0.f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Direction",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f,360.f,0.f), 
            }
        ),
        
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Scratches",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Wavyness",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 1.f, 0.1f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Scale",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 40.f, 20.f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Base Frequency",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 0.5f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"FrequencyStep",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 1.f, 0.25f), 
            }
        ),

        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Droplets",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Count",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 1.f, 0.1f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"OpacityJitter",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Size",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 10.f, 5.f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID,glm::vec2(1,2.f),"Element Properties",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Wetness",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Metallic",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 1.f, 0.f), 
                RangeBar(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f),"Height",Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET,0.f, 1.f, 1.f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1, 2.f), "Channel Opacities", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Albedo Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Roughness Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Metallic Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Normal Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Height Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1, 1.5f), "Ambient Occlusion Opacity", Texture(),MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f), 
            }
        ),
        Section(
            Element(Button(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Masking & Depth Properties",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, true)),
            {
                RangeBar(ELEMENT_STYLE_SOLID, glm::vec2(1.f, 2.f), "Depth Value",  Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, 0.f, 1.f, 1.f),
                CheckBox(ELEMENT_STYLE_BASIC, glm::vec2(1.f, 2.f), "Blur the Height Map", MATERIAL_MODIFIERS_ELEMENT_OFFSET)
            }
        ),
        Section(
            Element(Button()),
            {
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.5f), "Albedo Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false),
                Button(ELEMENT_STYLE_SOLID,glm::vec2(1,1.f), "Remove The Filter", Texture(), MATERIAL_MODIFIERS_ELEMENT_OFFSET, false)
            }
        )
    };

    sections[sections.size() - 1].elements[0].button.filterSelection = true;
    
    return sections;
}

void channelPrep(Material &material, Mesh &mesh, int& textureResolution, int& curModI, glm::mat4& perspective, glm::mat4& view, int& channelI, unsigned int& FBO, Texture& currentTexture, Texture& previousTexture, Texture& prevDepth){
    glDisable(GL_DEPTH_TEST);

    //Get the channel's texture from material
    
    if(channelI == 0){
        currentTexture = mesh.albedo;
    }
    if(channelI == 1){
        currentTexture = mesh.roughness;
    }
    if(channelI == 2){
        currentTexture = mesh.metallic;
    }
    if(channelI == 3){
        currentTexture = mesh.normalMap;
    }
    if(channelI == 4){
        currentTexture = mesh.heightMap;
    }
    if(channelI == 5){
        currentTexture = mesh.ambientOcclusion;
    }

    prevDepth = mesh.heightMap.duplicateTexture();

    /* ! Binds another framebuffer ! */
    previousTexture = currentTexture.duplicateTexture();

    //That framebuffer will be used to get the results of the shader 
    glGenFramebuffers(1,&FBO);
    glBindFramebuffer(GL_FRAMEBUFFER,FBO);

    //Bind the channel texture
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
    
    //Params for the channel texture
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_MIRRORED_REPEAT);
    
    //Refresh the channel texture
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, textureResolution, textureResolution, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
    glGenerateMipmap(GL_TEXTURE_2D);

    //Bind the channel texture to the capture framebuffer
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, currentTexture.ID, 0);
    
    glClearColor(0,0,0,1);
    glClear(GL_COLOR_BUFFER_BIT);
}

static void blurTheTexture(unsigned int& txtr, Mesh& mesh, int textureResolution){
    
    Texture textureObject = Texture(txtr);
    unsigned int textureCopy = textureObject.duplicateTexture();

    unsigned int FBO;
    glGenFramebuffers(1,&FBO);
    glBindFramebuffer(GL_FRAMEBUFFER,FBO);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, txtr, 0);
    glViewport(0, 0, textureResolution, textureResolution);

    glClearColor(0,0,0,0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    getBox()->bindBuffers();
    
    glm::mat4 projection = glm::ortho(0.f, (float)textureResolution, (float)textureResolution, 0.f); 
    ShaderSystem::bluringShader().use();
    ShaderSystem::bluringShader().setInt("txtr", 0);
    ShaderSystem::bluringShader().setInt("uvMask", 1);
    ShaderSystem::bluringShader().setVec2("txtrRes", glm::vec2(textureResolution));
    ShaderSystem::bluringShader().setMat4("projection"  ,       projection);
    ShaderSystem::bluringShader().setMat4("projectedPosProjection"  ,       projection);
    ShaderSystem::bluringShader().setVec3("pos"         ,       glm::vec3((float)textureResolution / 2.f, (float)textureResolution / 2.f, 0.9f));
    ShaderSystem::bluringShader().setVec2("scale"       ,       glm::vec2((float)textureResolution / 2.f));
    ShaderSystem::bluringShader().setFloat("blurVal"     ,     1.f);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, textureCopy);
    
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, mesh.uvMask);

    glDrawArrays(GL_TRIANGLES, 0 , 6);

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    
    glDeleteFramebuffers(1, &FBO);
    glDeleteTextures(1, &textureCopy);
}

glm::vec2 getDirectionVector(float rotation) {
  // Convert rotation from degrees to radians
  float radians = glm::radians(rotation);

  // Calculate the x and y components of the direction vector
  float x = glm::cos(radians);
  float y = glm::sin(radians);

  return glm::vec2(x, y);
}


void textureModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI){


    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);
    
    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
        //Set the OpenGL viewport to the texture resolution
        glViewport(0,0,textureResolution,textureResolution);
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, getScene()->projectionMatrix, getScene()->viewMatrix, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);

        //Set the uniforms of the modifier's shader
        material.materialModifiers[curModI].shader.use(); //Use the shader of the modifier
        material.materialModifiers[curModI].shader.setMat4("orthoProjection",projection); //Set the projection
        material.materialModifiers[curModI].shader.setMat4("perspectiveProjection",getScene()->projectionMatrix); //Set the projection
        material.materialModifiers[curModI].shader.setMat4("view",getScene()->viewMatrix); //Set the projection        
        material.materialModifiers[curModI].shader.setInt("state",channelI); //Set the texture slot
        material.materialModifiers[curModI].shader.setInt("theTexture",0); //Set the texture slot
        material.materialModifiers[curModI].shader.setInt("mask", 1); //Set the texture slot
        material.materialModifiers[curModI].shader.setInt("previousTxtr", 2); //Set the texture slot
        material.materialModifiers[curModI].shader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-3].elements[channelI].rangeBar.value); 
        material.materialModifiers[curModI].shader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[0].rangeBar.value); 
        material.materialModifiers[curModI].shader.setInt( "depthTxtr" , 3);

        //Bind the texture (bind the channel textures if rendering a texture modifier & bind the result of the previous modifier)
        glActiveTexture(GL_TEXTURE0);
        unsigned int proceduralChannelTexture = 0;
        proceduralChannelTexture = material.materialModifiers[curModI].sections[0].elements[channelI].button.texture.generateProceduralTexture(mesh, textureResolution);

        material.materialModifiers[curModI].shader.use();
        glBindFramebuffer(GL_FRAMEBUFFER, FBO);
        glBindTexture(GL_TEXTURE_2D, proceduralChannelTexture);
    
        // Bind the mask texture
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);

        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        glActiveTexture(GL_TEXTURE3);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);

        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        if(channelI == 0 && material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.shader.ID)
            material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.applyFilter(currentTexture.ID);
        glDeleteTextures(1, &previousTexture.ID);
        if(material.materialModifiers[curModI].sections[0].elements[channelI].button.texture.proceduralID != -1)
            glDeleteTextures(1, &proceduralChannelTexture);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void dustModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI){

    Shader modifierShader = material.materialModifiers[curModI].shader;


    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
        //Set the OpenGL viewport to the texture resolution
        glViewport(0,0,textureResolution,textureResolution);
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, getScene()->projectionMatrix, getScene()->viewMatrix, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setMat4("perspectiveProjection",getScene()->projectionMatrix); //Set the projection
        modifierShader.setMat4("view",getScene()->viewMatrix); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-3].elements[channelI].rangeBar.value);
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[0].rangeBar.value);
        modifierShader.setInt( "depthTxtr" , 2);

        /* Noise */
        modifierShader.setFloat("size", material.materialModifiers[curModI].sections[0].elements[0].rangeBar.value); 
        modifierShader.setFloat("offsetIntensity", material.materialModifiers[curModI].sections[0].elements[1].rangeBar.value); 
        modifierShader.setFloat("rotation", material.materialModifiers[curModI].sections[0].elements[2].rangeBar.value); 
        modifierShader.setFloat("brightness", material.materialModifiers[curModI].sections[0].elements[3].rangeBar.value); 
        /* Blur */
        modifierShader.setFloat("blurIntensity", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value);
        modifierShader.setVec2("blurDirection", getDirectionVector(material.materialModifiers[curModI].sections[1].elements[1].rangeBar.value));
        /* Scratches */
        modifierShader.setFloat("scratchesWavyness", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value); 
        modifierShader.setVec2("scratchesScale", glm::vec2(material.materialModifiers[curModI].sections[2].elements[1].rangeBar.value));
        modifierShader.setVec2("scratchesBaseFrequency", glm::vec2(material.materialModifiers[curModI].sections[2].elements[2].rangeBar.value));
        modifierShader.setVec2("scratchesFrequencyStep", glm::vec2(material.materialModifiers[curModI].sections[2].elements[3].rangeBar.value));
        /* Droplets */
        modifierShader.setFloat("dropletsCount", material.materialModifiers[curModI].sections[3].elements[0].rangeBar.value); 
        modifierShader.setFloat("dropletsOpacityJitter", material.materialModifiers[curModI].sections[3].elements[1].rangeBar.value);
        modifierShader.setFloat("dropletsSize", material.materialModifiers[curModI].sections[3].elements[2].rangeBar.value);

        /* Element property */
        modifierShader.setFloat("wetness", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value);
        modifierShader.setFloat("metallic", material.materialModifiers[curModI].sections[4].elements[1].rangeBar.value);
        modifierShader.setFloat("height", material.materialModifiers[curModI].sections[4].elements[2].rangeBar.value);
        

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);

        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);

        //Generating the normal map
        if(channelI == 4){
            if(material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[1].checkBox.clickState1)
                blurTheTexture(mesh.heightMap.ID, mesh, textureResolution);
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }

        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        if(channelI == 0 && material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.shader.ID)
            material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.applyFilter(currentTexture.ID);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void solidModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI){

    Shader modifierShader = material.materialModifiers[curModI].shader;


    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
        //Set the OpenGL viewport to the texture resolution
        glViewport(0,0,textureResolution,textureResolution);
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, getScene()->projectionMatrix, getScene()->viewMatrix, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",getScene()->projectionMatrix); //Set the projection
        modifierShader.setMat4("view",getScene()->viewMatrix); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state",channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[0].elements[channelI * 2 + 1].rangeBar.value); //Set the channel opacity
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[0].rangeBar.value); 
        modifierShader.setInt( "depthTxtr" , 2); //Set the channel opacity
        modifierShader.setVec3( "value" , glm::vec3(
                                                        material.materialModifiers[curModI].sections[0].elements[channelI * 2].button.color.r, 
                                                        material.materialModifiers[curModI].sections[0].elements[channelI * 2].button.color.g, 
                                                        material.materialModifiers[curModI].sections[0].elements[channelI * 2].button.color.b
                                                    )); //Set the channel color value

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);

        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        if(channelI == 0 && material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.shader.ID)
            material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.applyFilter(currentTexture.ID);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void asphaltModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI){

    Shader modifierShader = material.materialModifiers[curModI].shader;



    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
        //Set the OpenGL viewport to the texture resolution
        glViewport(0,0,textureResolution,textureResolution);
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, getScene()->projectionMatrix, getScene()->viewMatrix, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",getScene()->projectionMatrix); //Set the projection
        modifierShader.setMat4("view",getScene()->viewMatrix); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-3].elements[channelI].rangeBar.value); 
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[0].rangeBar.value); 
        modifierShader.setInt( "depthTxtr" , 2);

        /* Colors */
        modifierShader.setVec3("asphaltColor", material.materialModifiers[curModI].sections[0].elements[0].button.color);
        modifierShader.setVec3("asphaltColor2", material.materialModifiers[curModI].sections[0].elements[1].button.color);

        /* Dirt */
        modifierShader.setFloat("dirtScale", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value);
        modifierShader.setFloat("dirtStrength", material.materialModifiers[curModI].sections[1].elements[1].rangeBar.value);

        /* 2nd Color */
        modifierShader.setFloat("colorNoiseScale", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value);
        modifierShader.setFloat("colorNoiseStrength", material.materialModifiers[curModI].sections[2].elements[1].rangeBar.value);

        /* Noise */ 
        modifierShader.setFloat("noiseStrength", material.materialModifiers[curModI].sections[3].elements[0].rangeBar.value);

        /* Element property */
        modifierShader.setFloat("wetness", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value);
        modifierShader.setFloat("metallic", material.materialModifiers[curModI].sections[4].elements[1].rangeBar.value);
        modifierShader.setFloat("height", material.materialModifiers[curModI].sections[4].elements[2].rangeBar.value);

        /* Perlin Noise Properties*/
        modifierShader.setInt("firstOctave", material.materialModifiers[curModI].sections[5].elements[0].rangeBar.value);
        modifierShader.setInt("octaves", material.materialModifiers[curModI].sections[5].elements[1].rangeBar.value); 
        modifierShader.setFloat("persistence", material.materialModifiers[curModI].sections[5].elements[2].rangeBar.value); 

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        
        //Generating the normal map
        if(channelI == 4){
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        if(channelI == 0 && material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.shader.ID)
            material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.applyFilter(currentTexture.ID);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void liquidModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI){

    Shader modifierShader = material.materialModifiers[curModI].shader;



    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
        //Set the OpenGL viewport to the texture resolution
        glViewport(0,0,textureResolution,textureResolution);
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, getScene()->projectionMatrix, getScene()->viewMatrix, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",getScene()->projectionMatrix); //Set the projection
        modifierShader.setMat4("view",getScene()->viewMatrix); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-3].elements[channelI].rangeBar.value); 
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[0].rangeBar.value); 
        modifierShader.setInt( "depthTxtr" , 2);

        /* Scaling */
        modifierShader.setFloat("scale", material.materialModifiers[curModI].sections[0].elements[0].rangeBar.value);
        modifierShader.setFloat("yScale", material.materialModifiers[curModI].sections[0].elements[1].rangeBar.value);
        
        /* Noise */
        modifierShader.setInt("octaves", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value);
        modifierShader.setFloat("fbmXOffset", material.materialModifiers[curModI].sections[1].elements[1].rangeBar.value);
        modifierShader.setFloat("fbmYOffset", material.materialModifiers[curModI].sections[1].elements[2].rangeBar.value);
        modifierShader.setFloat("fbmXScale", material.materialModifiers[curModI].sections[1].elements[3].rangeBar.value);
        modifierShader.setFloat("fbmYScale", material.materialModifiers[curModI].sections[1].elements[4].rangeBar.value);
        modifierShader.setFloat("roughness", material.materialModifiers[curModI].sections[1].elements[5].rangeBar.value);
        modifierShader.setFloat("frequencyAcceleration", material.materialModifiers[curModI].sections[1].elements[6].rangeBar.value);
        modifierShader.setFloat("fbmTotal", material.materialModifiers[curModI].sections[1].elements[7].rangeBar.value);
        modifierShader.setFloat("seed", material.materialModifiers[curModI].sections[1].elements[8].rangeBar.value);
        
        /* General */
        modifierShader.setFloat("noiseInfluence", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value);
        modifierShader.setFloat("positionInfluence", material.materialModifiers[curModI].sections[2].elements[1].rangeBar.value);
        
        /* Colors */
        modifierShader.setVec3("color1", material.materialModifiers[curModI].sections[3].elements[0].button.color);
        modifierShader.setVec3("color2", material.materialModifiers[curModI].sections[3].elements[1].button.color);
        modifierShader.setVec3("color3", material.materialModifiers[curModI].sections[3].elements[2].button.color);
        modifierShader.setVec3("color4", material.materialModifiers[curModI].sections[3].elements[3].button.color);

        /* Element property */
        modifierShader.setFloat("wetness", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value);
        modifierShader.setFloat("metallic", material.materialModifiers[curModI].sections[4].elements[1].rangeBar.value);
        modifierShader.setFloat("height", material.materialModifiers[curModI].sections[4].elements[2].rangeBar.value);
        modifierShader.setFloat("ambientOcclusion", material.materialModifiers[curModI].sections[4].elements[3].rangeBar.value);

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        
        //Generating the normal map
        if(channelI == 4){
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        if(channelI == 0 && material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.shader.ID)
            material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.applyFilter(currentTexture.ID);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}


void woodenModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI){

    Shader modifierShader = material.materialModifiers[curModI].shader;



    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
        //Set the OpenGL viewport to the texture resolution
        glViewport(0,0,textureResolution,textureResolution);
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, getScene()->projectionMatrix, getScene()->viewMatrix, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",getScene()->projectionMatrix); //Set the projection
        modifierShader.setMat4("view",getScene()->viewMatrix); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-3].elements[channelI].rangeBar.value); 
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[0].rangeBar.value); 
        modifierShader.setInt( "depthTxtr" , 2);

        /* Colors */
        modifierShader.setVec3("woodColor1", material.materialModifiers[curModI].sections[0].elements[0].button.color);
        modifierShader.setVec3("woodColor2", material.materialModifiers[curModI].sections[0].elements[1].button.color);
        modifierShader.setVec3("woodColor3", material.materialModifiers[curModI].sections[0].elements[2].button.color);

        /* Properties */
        modifierShader.setFloat("scale", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value);
        modifierShader.setFloat("noiseOffset", material.materialModifiers[curModI].sections[1].elements[1].rangeBar.value);
        modifierShader.setFloat("seed", material.materialModifiers[curModI].sections[1].elements[2].rangeBar.value);

        /* Perlin Properties */
        modifierShader.setInt("maxOctaves", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value); 
        modifierShader.setFloat("persistance", material.materialModifiers[curModI].sections[2].elements[1].rangeBar.value);

        /* Musgrave Properties */
        modifierShader.setFloat("musgraveLacunarity", material.materialModifiers[curModI].sections[3].elements[0].rangeBar.value);
        modifierShader.setFloat("musgraveStrength", material.materialModifiers[curModI].sections[3].elements[1].rangeBar.value);
        modifierShader.setFloat("musgraveNoise", material.materialModifiers[curModI].sections[3].elements[2].rangeBar.value);

        /* Base */
        modifierShader.setFloat("baseNoiseStrength", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value);
        modifierShader.setFloat("baseColorSaturation", material.materialModifiers[curModI].sections[4].elements[1].rangeBar.value);

        /* FBM Properties */
        modifierShader.setFloat("fbmFrequency", material.materialModifiers[curModI].sections[5].elements[0].rangeBar.value);

        /* Element property */
        modifierShader.setFloat("woodGamma", material.materialModifiers[curModI].sections[6].elements[0].rangeBar.value);
        modifierShader.setFloat("shininess", material.materialModifiers[curModI].sections[6].elements[1].rangeBar.value);
        modifierShader.setFloat("metallic", material.materialModifiers[curModI].sections[6].elements[2].rangeBar.value);
        modifierShader.setFloat("height", material.materialModifiers[curModI].sections[6].elements[3].rangeBar.value);

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        
        //Generating the normal map
        if(channelI == 4){
            if(material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[1].checkBox.clickState1)
                blurTheTexture(mesh.heightMap.ID, mesh, textureResolution);
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        if(channelI == 0 && material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.shader.ID)
            material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.applyFilter(currentTexture.ID);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void mossModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI){

    Shader modifierShader = material.materialModifiers[curModI].shader;



    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
        //Set the OpenGL viewport to the texture resolution
        glViewport(0,0,textureResolution,textureResolution);
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, getScene()->projectionMatrix, getScene()->viewMatrix, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",getScene()->projectionMatrix); //Set the projection
        modifierShader.setMat4("view",getScene()->viewMatrix); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-3].elements[channelI].rangeBar.value); 
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[0].rangeBar.value); 
        modifierShader.setInt( "depthTxtr" , 2);

        /* Color */
        modifierShader.setVec3("mossColorBack", material.materialModifiers[curModI].sections[0].elements[0].button.color);
        modifierShader.setVec3("mossColorFront", material.materialModifiers[curModI].sections[0].elements[1].button.color);
        modifierShader.setVec3("dirtColor", material.materialModifiers[curModI].sections[0].elements[2].button.color);

        /* Droplets */
        modifierShader.setFloat("dropletsCount", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value);
        modifierShader.setFloat("dropletsOpacityJitter", material.materialModifiers[curModI].sections[1].elements[1].rangeBar.value);
        modifierShader.setFloat("dropletsSize", material.materialModifiers[curModI].sections[1].elements[2].rangeBar.value);

        /* Front Layer */
        modifierShader.setFloat("frontLayerStrength", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value);
        modifierShader.setFloat("frontLayerScale", material.materialModifiers[curModI].sections[2].elements[1].rangeBar.value);

        /* Lighting */
        modifierShader.setFloat("lightStrength", material.materialModifiers[curModI].sections[3].elements[0].rangeBar.value);
        modifierShader.setFloat("darkeningStrength", material.materialModifiers[curModI].sections[3].elements[1].rangeBar.value);

        /* Noise */
        modifierShader.setFloat("noiseStrength", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value);

        /* Moss Properties*/
        modifierShader.setFloat("scale", material.materialModifiers[curModI].sections[5].elements[0].rangeBar.value);

        /* Element property */
        modifierShader.setFloat("wetness", material.materialModifiers[curModI].sections[6].elements[0].rangeBar.value);
        modifierShader.setFloat("metallic", material.materialModifiers[curModI].sections[6].elements[1].rangeBar.value);
        modifierShader.setFloat("height", material.materialModifiers[curModI].sections[6].elements[2].rangeBar.value);

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        
        //Generating the normal map
        if(channelI == 4){
            if(material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[1].checkBox.clickState1)
                blurTheTexture(mesh.heightMap.ID, mesh, textureResolution);
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        if(channelI == 0 && material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.shader.ID)
            material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.applyFilter(currentTexture.ID);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void rustModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI){

    Shader modifierShader = material.materialModifiers[curModI].shader;



    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
        //Set the OpenGL viewport to the texture resolution
        glViewport(0,0,textureResolution,textureResolution);
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, getScene()->projectionMatrix, getScene()->viewMatrix, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",getScene()->projectionMatrix); //Set the projection
        modifierShader.setMat4("view",getScene()->viewMatrix); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-3].elements[channelI].rangeBar.value); 
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[0].rangeBar.value); 
        modifierShader.setInt( "depthTxtr" , 2);

        /* Colors */
        modifierShader.setVec3("color1", material.materialModifiers[curModI].sections[0].elements[0].button.color);
        modifierShader.setVec3("color2", material.materialModifiers[curModI].sections[0].elements[1].button.color);
        modifierShader.setVec3("color3", material.materialModifiers[curModI].sections[0].elements[2].button.color);
        modifierShader.setVec3("color4", material.materialModifiers[curModI].sections[0].elements[3].button.color);

        /*Properties*/
        modifierShader.setFloat("scale", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value);

        /* Perlin Properties */
        modifierShader.setInt("firstOctave", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value); 
        modifierShader.setInt("octaves", material.materialModifiers[curModI].sections[2].elements[1].rangeBar.value);
        modifierShader.setFloat("persistence", material.materialModifiers[curModI].sections[2].elements[2].rangeBar.value); 

        /* FBM Properties*/
        modifierShader.setInt("fbmOctaves", material.materialModifiers[curModI].sections[3].elements[0].rangeBar.value); 
        modifierShader.setFloat("fbmRoughness", material.materialModifiers[curModI].sections[3].elements[1].rangeBar.value);

        /* Rust Properties */
        modifierShader.setFloat("rustRadius", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value);
        modifierShader.setFloat("batteringStrength", material.materialModifiers[curModI].sections[4].elements[1].rangeBar.value);

        /* Noise Properties*/
        modifierShader.setFloat("noiseStrength", material.materialModifiers[curModI].sections[5].elements[0].rangeBar.value);

        /* Element property */
        modifierShader.setFloat("wetness", material.materialModifiers[curModI].sections[6].elements[0].rangeBar.value);
        modifierShader.setFloat("metallic", material.materialModifiers[curModI].sections[6].elements[1].rangeBar.value);
        modifierShader.setFloat("height", material.materialModifiers[curModI].sections[6].elements[2].rangeBar.value);

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        
        //Generating the normal map
        if(channelI == 4){
            if(material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[1].checkBox.clickState1)
                blurTheTexture(mesh.heightMap.ID, mesh, textureResolution);
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        if(channelI == 0 && material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.shader.ID)
            material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.applyFilter(currentTexture.ID);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}

void skinModifierUpdateMat(Material &material, Mesh &mesh, int textureResolution, int curModI){

    Shader modifierShader = material.materialModifiers[curModI].shader;
    

    //Set the orthographic projection to the texture resolution
    glm::mat4 projection = glm::ortho(0.f,1.f,0.f,1.f);

    //Transform values to take the texture in to the middle of the screen and cover it completely
    glm::vec2 fragScale = glm::vec2((float)textureResolution/2.f,(float)textureResolution/2.f);
    glm::vec3 fragPos = glm::vec3((float)textureResolution/2.f,(float)textureResolution/2.f,1.0f);

    //TODO Don't create the shader in the modifier function

    Texture prevDepthTexture;
    prevDepthTexture = mesh.heightMap.duplicateTexture();
    //Disable the depth test (just in case)
    
    unsigned int proceduralTexture;
    proceduralTexture = material.materialModifiers[curModI].maskTexture.generateProceduralTexture(mesh, textureResolution);

    for (int channelI = 0; channelI < 6; channelI++){
        //Set the OpenGL viewport to the texture resolution
        glViewport(0,0,textureResolution,textureResolution);
    
        unsigned int FBO;
        Texture currentTexture;
        Texture previousTexture;
        channelPrep(material, mesh, textureResolution, curModI, getScene()->projectionMatrix, getScene()->viewMatrix, channelI, FBO, currentTexture, previousTexture, prevDepthTexture);
        
        //Set the uniforms of the modifier's shader
        modifierShader.use(); //Use the shader of the modifier
        modifierShader.setMat4("orthoProjection",projection); //Set the projection
        modifierShader.setVec2("scale",fragScale); //Set the scale
        modifierShader.setVec3("pos",fragPos); //Set the position
        modifierShader.setMat4("perspectiveProjection",getScene()->projectionMatrix); //Set the projection
        modifierShader.setMat4("view",getScene()->viewMatrix); //Set the projection

        /* Channel Properties */
        modifierShader.setInt("state", channelI); //Set the channel state
        modifierShader.setInt("mask", 0); //Set the mask texture slot
        modifierShader.setInt("previousTxtr", 1); //Set the previous texture slot
        modifierShader.setFloat( "opacity" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-3].elements[channelI].rangeBar.value); 
        modifierShader.setFloat( "depthValue" , material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[0].rangeBar.value); 
        modifierShader.setInt( "depthTxtr" , 2);

        /* Droplets */
        modifierShader.setFloat("dropletsCount", material.materialModifiers[curModI].sections[0].elements[0].rangeBar.value);
        modifierShader.setFloat("dropletsOpacityJitter", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value);
        modifierShader.setFloat("dropletsSize", material.materialModifiers[curModI].sections[0].elements[2].rangeBar.value);

        /* Veins */
        modifierShader.setFloat("veinsScale", material.materialModifiers[curModI].sections[1].elements[0].rangeBar.value);
        modifierShader.setFloat("veinsStrength", material.materialModifiers[curModI].sections[1].elements[1].rangeBar.value);

        /* Blushing */
        modifierShader.setFloat("blushingStrength", material.materialModifiers[curModI].sections[2].elements[0].rangeBar.value);

        /* Skin Prints */
        modifierShader.setFloat("skinPrintsScale", material.materialModifiers[curModI].sections[3].elements[0].rangeBar.value);
        modifierShader.setFloat("skinPrintsStrength", material.materialModifiers[curModI].sections[3].elements[1].rangeBar.value);

        /* Noise */
        modifierShader.setFloat("noiseStrength", material.materialModifiers[curModI].sections[4].elements[0].rangeBar.value);

        /* Skin Properties*/
        modifierShader.setInt("skinColorType", material.materialModifiers[curModI].sections[5].elements[0].rangeBar.value);
        modifierShader.setFloat("skinScale", material.materialModifiers[curModI].sections[5].elements[1].rangeBar.value);
        modifierShader.setFloat("skinWetness", material.materialModifiers[curModI].sections[5].elements[2].rangeBar.value);
        modifierShader.setFloat("skinMetallic", material.materialModifiers[curModI].sections[5].elements[3].rangeBar.value);
        modifierShader.setFloat("skinHeight", material.materialModifiers[curModI].sections[5].elements[4].rangeBar.value);
        modifierShader.setFloat("skinAmbientOcclusion", material.materialModifiers[curModI].sections[5].elements[5].rangeBar.value);

        // Bind the mask texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, proceduralTexture);


        //Bind the previous height texture      
        glActiveTexture(GL_TEXTURE2);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, prevDepthTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, 0);
        
        //Bind the previous texture
        glActiveTexture(GL_TEXTURE1);
        if(curModI != material.materialModifiers.size()-1)
            glBindTexture(GL_TEXTURE_2D, previousTexture.ID);
        else
            glBindTexture(GL_TEXTURE_2D, currentTexture.ID);
        
        //Render the result to the framebuffer
        mesh.Draw();
        
        //Just in case 🤫😁🤑 
        glGenerateMipmap(GL_TEXTURE_2D);
        
        //Delete the framebuffer after completing the channel
        glDeleteFramebuffers(1,&FBO);
        
        //Generating the normal map
        if(channelI == 4){
            if(material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-2].elements[1].checkBox.clickState1)
                blurTheTexture(mesh.heightMap.ID, mesh, textureResolution);
            mesh.heightMap.generateNormalMap(mesh.normalMap.ID, textureResolution, 10.f, false);
            mesh.normalMap.removeSeams(mesh, textureResolution);
        }
        glEnable(GL_DEPTH_TEST);

        currentTexture.removeSeams(mesh,textureResolution);
        if(channelI == 0 && material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.shader.ID)
            material.materialModifiers[curModI].sections[material.materialModifiers[curModI].sections.size()-1].elements[0].button.filter.applyFilter(currentTexture.ID);
        glDeleteTextures(1, &previousTexture.ID);
    }
    glDeleteTextures(1, &prevDepthTexture.ID);
    glDeleteTextures(1, &proceduralTexture);
}